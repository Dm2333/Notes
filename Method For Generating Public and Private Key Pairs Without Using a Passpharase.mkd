

#Method for Generating Public and Private Key Pairs without Using a Passphrase

##Background of The Invention

The cryptographic architecture described in the cited patents by S. M. Matyas, et a1. is based on associating with a cryptographic key, a control vector which provides the authorization for the uses of the key intended by the originator of the key. 

The cryptographic architecture described in the cited patents by S. M. Matyas, et al. is based on the Data Encryption Algorithm (DEA), see American National Standard X3.92-198l, Data Encryption Algorithm, American National Standards Institute, New York (Dec. 31, 1981), whereas the present invention is based on both a secret key algorithm, such as the DEA, and a public key algorithm. Various key management functions, data cryptography functions, and other data processing fimctions are possible using *control vectors*, in accordance with the invention. A system administrator can exercise flexibility in the implementation of his security policy by selecting appropriate control vectors in accordance with the invention. 

A cryptographic facility (CF) in the crypto graphic architecture is described in the above cited , patents by S. M. Matyas, et al. **The CF is an instruction processor for a set of cryptographic instructions**, implementing encryption methods and key generation methods. A memory in the cryptographic facility stores a set of internal cryptographic variables. **Each cryptographic instruction is described in terms of a sequence of processing steps required to transform a set of input parameters to a set of output parameters**. 

A crypto graphic facility application program (CFAP) is also described in the referenced patents and patent applica tions, which defnes an invocation method, as a calling sequence, **for each cryptographic instruction consisting of an instruction mnemonic and an address with corresponding input and output parameters**.

Public key encryption algorithms are described in a paper by W. Dif?e and M. E. Hellman entitled ¡°Privacy and Authentication: An Introduction to Cryptography,¡± Proceedings of the IEEE, Vol. 67, No. 3, March 1979, pp. 397-427. Public key systems are based on dispensing with the secret key distribution channel, as long as the channel has a sufficient level of integrity. In a public key cryptographic system, two keys are used, one for enciphering and one for deciphering. Public key algorithm systems are designed so that 

    1. it is easy to generate a random pair of inverse keys PU (for enciphering) and PR (for deciphering) and 
    2. it is easy to operate with PU and PR, but 
    3. it is computationally infeasible to compute PR from PU. 

Each user generates a pair of inverse transforms, PU and PR. The user keeps the deciphering transformation PR secret, and makes the enciphering transformation PU public by placing it in a public directory. Anyone can now encrypt mes sages and send them to the user, but no one else can decipher messages intended for him. It is possible, and often desirable, to encipher with PU and decipher with PR. For this reason, PU is usually referred to as a public key and PR is usually referred to as a private key. A corollary feature of public key cryptographic systems is the provision of a digital signature which uniquely identites the sender of a message. If user A wishes to send a signed message M to user B, he operates on it with his private key PR to produce the signed message S. PR was used as A's deciphering key when privacy was desired, but it is now used as his ¡°enciphering¡± key.  When user B receives the message S, he can recover the message M by operating on the ciphertext S with A's public PU. By successfully decrypting A¡¯s message, the receiver B has conclusive proof it came from the sender A. Examples of public key cryptography are provided in the following US. patents: US. Pat. No. 4,218,582 to Hellman, et al., ¡°Public Key Cryptographic Apparatus and Method;¡± US. Pat. No. 4,200,770 to Hellman, et al., ¡°Cryptographic Apparatus and Method;¡± and US. Pat. 0 No. 4,405,829 to Rivest, et al., ¡°Cryptographic Communications System and Method.¡±

In most cryptographic systems, once a cryptographic key has been generated, it may be stored in encrypted form in a cryptographic key data set or it may be trasmitted in encrypted form from the generating device to a receiving device where it is re-encrypted in a form suitable for storage and use at the receiving device.  Keys are ported from one device to another by writing them on a suitable medium (e.g., diskette, magnetic tape, memory card, smart card) and transporting the medium or by electronically transmitting the keys.  However, when the key being transported or transmit ted is a secret key, such as a secret key used with a symmetric key cryptographic algorithm (e.g., the Data Encryption Algorithm) or the private key of a public and private key pair used with an asymmetric key cryp tographic algorithm, there is an ever present danger that the key may be intercepted by an adversary. One method for securely transporting or transmitting secret or private keys is to encrypt them with a key shared between the sending and receiving devices. However, there are situations where the sending and receiving devices do not share such a key that would facilitate such a secure encryption channel, or where it would be inconvenient or impossible for the sending and receiv ing devices to establish such a keying relationship in order to facilitate such a secure encryption channel.  Therefore, there are times when the only convenient means to port a secret key from one device to another is by porting a clear key.

##Objects of The Invention

It is therefore an object of the invention to provide an improved method for users to port their public and private keys from one cryptographic system to another. 

It is another object of the invnetion to permit users to port their public and private keys from one cryptographic system to another **without requiring a separate storage medium**, such as a diskette, magnetic tape, memory card, or smart card

It is another object of the invention to permit a user¡¯s public and private keys to be generated and used during periods when the user is actively using a cryptographic device and to permit the keys to be purged from the cryptographic device when the user is not using the cryptographic device

It is another object of the invention to permit a user's public and private keys to be initialized within a portable computer with a cryptographic capability during periods when the urer requires cryptographic services and to purge the key from the portable computer when cryptographic services are not required.

It is another object of the invention to provide a method whereby a user¡¯s public and private key pair can be generated, or re-generated at any cryptographic device within a network of cryptographic devices solely from **something that the user remembers, such as a passphrase**.

It is another object of the invention to provide a method for constructing passphrases that **ensures that the number of passphrase combinations is greater than a number equal to 2 to the power 128**, yet the passphrases have enough redundancy within them that users can easily remember them.

> Why 2 to the power 128? 128bit RSA is insecure now.

It is antoher object of the invention to provide **a method for generating and re-generating public and private key pairs from an input passphrase** where the key generation algorithm is based on any public key cryptographic algorithm.

It is antoher object of the invention to provide a key management system that permits the key generation algorithm to produce public and private key pairs of a first type not based on a passphrase and of a second type based on a passphrase.

It is another object of the invention to provide a key management system that permits public and private key pairs of a first type not based on a passphrase to have a ?rst key usage based on a ?rst set of allowed key usages and that permits public and private key pairs of a second type based on a passphrase to have a second key usage based on a second set of allowed key usages.

It is another object of the invention to provide **a key management system wherein public and private keys generated from passphrases can be cryptographically separated from public and private keys not generated from passphrases**, so that public and private keys generated from passphrases cannot weaken the overall security of a cryptographic system that makes use of both types of generated public and private keys.

##Summary of The Invention

These and other objects, features, and advantages are accomplished by the invention disclosed herein. The present invention provides an alternative means for porting secreat or public keys from one device to another device in a network of cryptographci devices. It also provides a means for users of a cryptographic devices to purge their secret keys during tmies when they are not actively using the cryptographic device and to regenerate their secret keys during times when they are actively using the cryptographic device. This is accomplished by **initially generating the public and private key pair from a passphrase provided to the key generation algorithm by the user**. Thereafter, each time it is necessary to re-generate the same key pair, the user again enters the same passphrase, from which the key generation algorithm derives the same public and private key pair. Such a procedure might be used by a single user who owns a portable programmable computer (PC) possessing a cryptographic capability. During times when the user is traveling, the keys are purged from the system.  During times when the user is using the cryptographic system, the keys are re-generated. A passphrase is simi lar in concept to a password, except that it may be longer, for example, eighty characters or more. As the passphrase may contain more characters, it may contain more variability than a password, yet it is easy for a user to remember a passphrase.

FIG. 1 is a block diagram illustration of a cryptographic system A shared by two users, i and j who generate their public and private key pair when using the device but purge their keys when not using the device.

![fig1_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase](./img/cryptography/fig1_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase.png)

Referring now to FIG. 1, at time t0, a first user, user i, causes his public and private keys PUi and PRi to be re-generated at cryptographic system A by entering his passphrase and invoking a GENERATE KEY function. From time t0 to time t1, user i actively uses his cryptographic keys. At time t1, user i purges his public and private keys PUi and PRi by invoking a PURGE KEY function. At time t2, a second user, user j, causes his public and private keys PUj and PRj to be re generated at cryptographic system A by entering his passphrase and invoking a GENERATE KEY function. From time t2 to time t3, user j actively uses his cryptographic keys. At time t3, user j purges his public and private keys PUj and PRj by invoking a PURGE KEY function. The PURGE KEY function as de scribed here purges both the public and private keys. In reality, **it would be sufficient to purge only the private key**.

> generate and purge

FIG. 2 is a block diagram illustration of crypto graphic systems A and B shared by a single user i who generates his public and private key pair when desiring to use a device and purges his keys when ?nished using the device. Referring now to FIG. 2, at time t0, user i causes his public and private keys PUi and PRi to be re-generated at cryptographic system A by entering his passphrase and invoking a GENERATE KEY func tion. From time t0 to time t1, user i actively uses his cryptographic keys. At time t1, user i purges his public and private keys PUi and PRi by invoking a PURGE KEY function. From time t1 to time t2, the user travels from cryptographic system A to cryptographic system B. At time t2, user i causes his public and private keys PUi and PRi to be re-generated at cryptographic system B by entering his passphrase and invoking a GENER ATE KEY function. From time t2 to time t3, user i actively uses his cryptographic keys. At time t3, user i purges his public and private keys PUi and PRi by invoking a PURGE KEY function.

![fig2_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase](./img/cryptography/fig2_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase.png)

> regenerate from different device

The passphrase is composed of words or phrases taken from a natural language, for example, English. Exmaple [not necessarily good choices] of passphrases are these:

    ¡°Time ?ies like the wind, but fruit ?ies like bananas.¡±
    ¡°Don¡¯t worry, what can possibly wrong?¡± "My father
    bought my brother a dog because he was an only child."

Since the passphrase contains a meaningful sequence of words, a user is able to remember or recall the passphrase, **even when the passphrase contains 80 char acters (including blanks) or more**. In such situations, the number of passphrase combinations can easily exceed a number equal to 2 to the power 128 (i.e., more than the number of combination in a double length DEA key). 

**The user is also provided with a set of instructions or guidelines for create passphrases**. This ensures that the user will not inadvertently use a passphrase that an adversary might easily guess, e.g., ¡°Mary had a little lamb . . . ¡± While such a passphrase is long, once the first two words are known, the rest follows. The reader will readily appreciate the infeasibility of an adversary guessing a passphrase like this: ¡°Donald Duck, Jack Benny, and Alfred the Great played chess while eating golf balls.¡± 

During key generation, **the passphrase is used as a seed value** to generate the necessary random numbers used by the key generation algorithm in the process of generating the keys. No other random num bers are used by the key generation algorithm except those which are generated from the passphrase. Because **the generated public and private key pair (PU, PR) are dependent only on the passphrase**, (PU,PR) can be re-generated at any cryptographic device within a net work of cryptographic devices that implement the same key generation algorithm. This would be the case if the network is composed of cryptographic devices pur chased from a single vendor or if the method of key generation is standardized and implemented in several products available from different vendors.

##Brief Description of The Drawings

These and other objects, features, and advantages of the invention will be more fully appreciated with refer ence to the accompanying ?gures.

FIG. 1 is a block diagram illustration of public and private key pair generation from a passphrase in crypto graphic system A shared by users i and j.

FIG. 2 is a block diagram illustration of public and private key pair generation from a passphrase in crypto graphic systems A and B by user i.

FIG. 3 illustrates a communications network 10 in cluding a plurality of data processors, each of which includes a cryptographic system.

FIG. 4 is a block diagram of a cryptographic system 22.

FIG. 5 is a block diagram of a cryptographic facility 30.

FIG. 6 is a block diagram of the cryptographic algorithms 144 component of cryptographic facility 30.

FIG. 7 is a block diagram of the key generation algo rithm 151 component of,cryptographic facility 30 illustrating the steps involved in generating RSA keys.

FIG. 8 is a block diagram illustration of a ¡°true¡± random number generator 180.

FIG. 9 is a block diagram illustration of an initially seeded pseudorandom number generator 190.

FIG. 10 is a block diagram illustration of a dynamically swded pseudorandom number generator 200.

FIG. 11 is a block diagram of the cryptographic algorithms 144 component of the cryptographic facility 30, which has been modi?ed to include a dynamically seeded pseudorandom number generator 200, in accordance with the invention.

FIG. 12 is a block diagram illustration of a specific example of a dynamically seeded pseudorandom number generator.

FIG. 13 is a block diagram showing the steps involved in generating a public and private key pair from an input passphrase, in accordance with the invention.

FIG. 14 is a block diagram illustration of the Generate Public and Private Key Pair (GPUPR) instruction, in accordance with the invention.

FIG. 15 is a block diagram illustration of PU and PR key tokens.

FIG. 16 is a block diagram illustration of the control vector portion of a PU or PR key token.

FIG. 17 is a block diagram illustration of the passphrase selection process.

FIG. 18 is a block diagram illustration of a cryptographic system using a passphrase ?lter to test a trial passphrase supplied by a user application.

FIG. 19 is a block diagram illustration of the functional elementsv of a passphrase ?lter.

----

##Discussion of The Preferred Embodiment

The concept of generating a key from a character string supplied by a user of a cryptographic system has been implemented within IBM's Information Protection System (IPS), see Information Protection System Cryp tographic Programs for VM/CMS Users Guide, Order No. SH20-262l, IBM Corporation, August 1982. The Information Protection System is **a fle protection system designed around the concept that keys used to encrypt or decrypt a data fles are controlled and managed by users of the cryptographic system**. There are no system-owned keys. At the time data encryption or decryption services are required, the user must specify the key to the cryptographic system. 

The user may specify either a 16 hexadecimal digit key or a character string of up to 80 characters. When a character string is entered, **the IPS ¡°crunches¡± (i.e., hashes) the input character string into a 56-bit key** using the following method. 

The input character string is padded on the right with blanks to a length of 80 characters. The input character string is then divided into blocks of eight characters. The resulting padded data is then encrypted with the DEA using Cipher Block Chaining (CBC) mode of encryption using a constant key whose value is X'OlOlOlOlOlOlOlOl' and an Initial Chaining Value whose value is X". The rightmost 56 bits of the final 64-bit block of ciphertext is taken as the ¡°crunched¡± data key (without parity bits).


The method for producing a data key from a character string in the Information Protection System does not extend to the production of public and private key pairs.  This is so because the public key generation algorithm is more complex. In order to generate the public and pri vate key pair from a passphrase supplied by a user, the key generation algorithm itself must be modified and a dynamically seeded pseudorandom number generator must be used. 

A dynamically seeded pseudorandom number generator is an algorithmic procedure which generates a random number from a seed value specified as an input to the generator. Such pseudorandom number generators are **not suitable for the production of most random numbers within a cryptographic system, since the invoker of the random number generator does not, or often will not, have a seed value in hand that can be specified as an input**. Thus, in practice, there is no convenient way to use a dynamically seeded pseudorandom number generator within most cryptographic systems. Instead, these cryptographic systems will use an initially seeded pseudorandom number generator or special hardware that can generate true random numbers. Consequently, where it is deemed advantageous to practice the method of the present invention, it will be necessary for a cryptographic system to implement two random number generators: 

1. an initially seeded pseudorandom number generator or a hardware generator of true random nubmers, and 
2. a dynamically seeded pseudorandom number generator.

Moreover, it will be necessary to adopt a design for the key generation algorithm that permits public and private keys to be generated by making use of a dynamically seeded pseudorandom number generator. These aspects of the present invention will be more fully explained below.

U.S. Pat. No. 4736423 ¡°Technique for Reducing RSA Crypto Variable Storage¡±, cited above, describes a method for calculating a nonsecret value y of 50 bits from a secret value x of 56 bits, which can be used at any later time to regenerate public and private keys having a 4(D-bit modulus and a 400-bit exponent. For larger exponent and modulus lengths, the length of y increases only slightly while a remains constant at 56 bits. The secret value x is provided as an input to the key generation algorithm, which in addition to calculating public and private keys PU and PR, it also calculates the 50-bit value y. 

The value y is special in the sense that together with x it permits the public and private RSA keys PU and PR to be re-generated very quickly, relative to the time it originally took to gener ate PU and PR. The technique is a compromise between storing PU and PR (i.e., the full exponents and modulus), on the one hand, and regenerating PU and PR each time they are needed, on the other hand. The technique in U.S. Pat. No. 4,736,423 **reduces the number of bits that must be stored at the expense of requiring a short computation step to re-generate the keys**. In the present invention, the public and private keys are generated entirely from a passphrase that the user must remember. In contrast, the method in U.S. Pat. No.  4,736,423 while making use of an independent variable x of 56 bits, which could in theory be obtained by hashing an input passphrase, the value y is a dependent variable of 50 bits. This means that to port the public and private keys, **the user must port the dependent variable y and enter it together with independent variable x in order for the cryptographic system to regenerate the public and private key pair**. While the method in U.S. Pat. No.  4,736,423 has some of the advantages of the present invention, the present invention makes possible the transportation of the keys from one device to another independent of any additional information other than the passphrase. Therefore, the present invention permits a form of key porting that is unobtainable with the method in U.S. Pat. No. 4,736,423.

Environment Description for the Invention Disclosed. FIG. 3 illustrates a network block diagram showing a communications network 10 to which is connected a plurality of data processors including data processor 20, data processor 20', and data processor 20". Also included in each data processor is a cryptographic system, as shown in FIG. 3. Data processor 20 includes cryptographic system 22, data processor 20¡¯ includes cryptographic system 22¡¯ and data processor 20" includes cryptographic system 22". Each data processor supports the processing of one or more applications which require access to cryptographic services such as for the encryption, decryption and authenticat ing of application data and the generation and installation of cryptographic keys. The cryptographic services are provided by a secure cryptographic facility in each cryptographic system. The network provides the means for the data processors to send and receive encrypted data and keys. Various protocols, that is, formats and procedural rules, govern the exchange of cryptographic quantities between communicating data processor in order to ensure the interoperability between them.

![fig3_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase](./img/cryptography/fig3_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase.png)

FIG. 4 illustrates the cryptographic system 22 for the invention disclosed herein. In the cryptographic system 22, the cryptographic facility (CF) 30 has an input 37 from a physical interface. The cryptographic facility access program (CFAP) 34 is coupled to the cryptographic facility 30 by means of the interface 31. The cryptographic key data set (CKDS) 32 is connected to the cryptographic facility access program 34 by means of the interface 33. The application programs (APPL) 36 are connected to the cryptographic facility access program 34 by means of the interface 35.

![fig4_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase](./img/cryptography/fig4_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase.png)

A typical request for cryptographic service is initiated by APPL 36 via a function call to the CFAP 34 at the interface 35. The service request includes key and data parameters, as well as key identifiers which the CFAP 34 uses to access encrypted keys from the CKDS 32 at the interface 33. The CFAP 34 processes the service request by issuing one or more cryptographic access instructions to the CF30 at the interface 37 for direct entry of cryptographic variables into the CF 30. Each cryptographic access instruction in voked at the interface 31 has a set of input parameters processed by the CF 30 to produce a set of output parameters returned by the CF 30 to the CFAP 34. In turn, the CFAP 34 may return output parameters to the APPL 36. The CFAP 34 may also use the output parameters and input parameters to subsequently invoke instructions. If the output parameters contain encrypted keys, then the CFAP 34, in many cases, may store these encrypted keys in the CKDS 32.

FIG. 5 illustrates the cryptographic facility 30 for the invention disclosed herein. The cryptographic facility 30 is maintained within a secure boundary 140. The cryptographic facility 30 includes the instruction processor 142 which is coupled to the cryptographic algorithms 144 which are embodied as executable code. The cryptographic facility environment momery 146 is coupled to the instruction processor 142. The physical interface can be coupled over line 37 to the CF environment memory 146, as shown in the figure. The instruction processor 142 is coupled to the cryptographic facility access program (CFAP) 34 by means of the interface at 31.

![fig5_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase](./img/cryptography/fig5_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase.png)

The instruction processor 142 is a functional element which executes cryptographic microinstructions invoked by the CFAP access instruction at the interface 31. For each access instruction, the interface 31 first defines an instruction mnemonic or operation code used to select particular microinstructions for execution.  Secondly a set of input parameters is passed from the CFAP 34 to the CF 30. Thirdly, a set of output parameters is returned by the CF 30 to the CFAP 34. The instruction processor 142 executes the selected instruction by performing an instruction specific sequence of cryptographic processing steps embodied as microinstructions stored in cryptographic microinstruction memory 144. The control flow and subsequent output of the cryptographic processing steps depend on the values of the input parameters and the contents of the CF environment memory 146. The CF environment memory 146 consists of a set of cryptographic variables, for example keys, ?ags, counters, CF configuration data, etc., which are collectively stored within the CF 30. The CF environment variables in memory 146 are initialized via the interface 31, that is by execution of certain CF microinstructions which read input parameters and load them into the CF environement memory 146. Alternately, initialization can be done via an optional physical interface which permits cryptographic ivariables to be loaded directly into the CF environment memory 146, for example via an attached key envry device.

The physical embodiment of the cryptographic facility secure boundary 140, incorporate the following physical security features. The physical embodiment **resists probing** by an insider adversary who has limited access to the cryptographic facility 30. The term "limited" is measured in minutes or hours as opposed to days or weeks. The adversary is constrained to a probing attack at the customer's site using limited electronic devices as opposed to a laboratory attack launched at a site under the control of the adversary using sophisticated electronic and mechanical equipment. The physical embodiment also **detects attempts at physical probing or intruding**, through the use of a variety of electromechanical sensing devices. Also, the physical embodiment of the cryptographic facility 30 **provides for the zeroization of all internally stored secret cryptographic variables**. Such zeroization is done automatically whenever an attempted probing or intrusion has been detected. The physical embodiment also **provides a manual facility for a zeroization of internally stored secreate cryptographic variables**. References to the Abraham, etal. patent application cited above, will give an example of how such physical security features can be implemented.

Key Generation Process: FIG. 6 is a block diagram illustration of the Cryptographic Algorithms 144 contained in the cryptographic facility 30 for the invention disclosed herein. Referring to FIG. 6, the cryptographic algorithms 144 includes a cryptographic algorithm 150 that performs the operations of encryption and decryption, a key generation algorithm (KGA) 151 for the production of keys, and a random number generation algorithm 152 for the production of random numbers. For the present, we shall make no distinction between random and pseudorandom numbers, i.e., random number generation algorithm 152 may be a true random nubmer generator or an algorithm that produce pseudorandom numbers. Random number generators and pseudorandom number generators are discussed below. Cryptographic algorithm 150 may be a symmetric algorithm such as the Data Encryption Algorithm (see American National Standard X3.92-l98l, Data Encryption Algorithm, American National Stan dards Institute, New York (Dec. 31, 1981)), or it may be an asymmetric, or public key, algorithm such as the RSA algorithm. For public key algorithms, there may or may not be a distinction between the mathematical operations of encryption and decryption. For example, in the RSA algorithm both encryption and decryption are performed as exponentiation modulo a composite number. Cryptographic algorithm 150 is accessed by instruction processor 142 via interface 153, which permits instruction processor 142 to perform elementary operations of encryption and decryption. Interface 153 also permits keys, data, and other cryptographic variables to be passed between cryptographic algorithm 150 and instruction processor 142. In like manner, key gen eration algorithm 151 is accessed by instruction proces sor 142 via interface 154, which permits instruction processor 142 to request the production of keys. Interface 154 also permits keys, data, and other cryptographic variables to be passed between the two respective components. Key generation algorithm also interfaces to random number generation algorithm 152 via interface 155. This permits the key generation algorithm 151 to request and receive random numbers from random number generation algorithm 152, which are necessary to the key generation process. Random number generation algorithm 152 also interfaces to instruction processor 142 via interface 156, which permits instruction processor 142 to request the production of random numbers that are needed for cryptographic purposes other than for the production of keys.

![fig6_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase](./img/cryptography/fig6_method_for_generating_public_and_private_key_pairs_without_using_a_passpharase.png)

In the case where cryptographic algorithm 150 is **a symmetric or private key cryptographic algorithm such as the DEA**, the steps for generating keys with key generation algorithm 151 are simple. In general, the process of generating an n-bit key, say n= 64, consists of the following steps. A 64-bit random number RN is requested from random number generation algorithm 152. In some cases, RN may be taken directly as the to-be-generated key. However, in many cryptographic systems, key generation also involves a step of adjusting each byte of the key for odd parity. In still other cases, the key generation algorithm may test the key value to ensure that it does not have some perceived undesired property, e.g., the key is not a ¡°weak¡± or ¡°semi-weak¡± key. See Meyer and Matyas, Cryptography-A New Dimension in Computer Data Security, John Wiley & Sons, New York, 1982, for a specification of ¡°weak¡± and ¡°semi-weak¡± DEA keys. In most cases, such additional tests are ignored, although it is common practice in many cryptographic systems to adjust the parity of the key.

In the case where cryptographic algorithm 150 is **an asymmetric or public key cryptographic algorithm such as the RSA algorithm**, the steps for generating keys with key generation algorithm 151 are more involved.  In public key cryptographic systems, the public and private key pairs (PU1,PR1), (PU2,PR2), etc. are produced with the aid of a special Key Generation Algorithm (KGA). The KGA involves a combination of processes in which, at times, the KGA produces or requests the production of random numbers which it then uses in the production of the keys. These random values may be tested and rejected, and other random numbers may be requested and tested until certain mathematical properties are satisfied. In still other cases, the KGA may take a random value, or a random value that has been accepted after being tested for some mathematical property or properties, and from this random value it will then derive one or more other values. In general, the KGA requires some random component or components (i.e., random numbers) in the production of the keys. Otherwise, the same public and private key pair would be generated each time the KGA is invoked. This, of course, would be unacceptable-the KGA must produce public and private key pairs (PU1,PR1), (PU2,PR2), etc. that are, or at least appear, randomly drawn from the space of possible key pairs, thus ensuring that an adversary has no means to guess the key pairs produced by the KGA. As said, in addition to making use of random numbers in the production of its keys, the KGA makes use of mathematical processes wherein values are calculated, or derived, from other values (i.e., using a constructive process), and values are calculated using a process of trial and error (i.e., trial values are tested and rejected until the necessary value or values are found). The preferred embodiment is to use the seed value to initialize the pseudorandom number generator rather than using the seed value directly in the key generation algorithm because the pseudorandom number generator can, as needed by the key generation algorithm, generate a pseudorandom number of any arbitrary length, while the seed value, of necessity, is of a specific finite length which implies there is a non-zero probability that the key generation algorithm will need more random bits than are in the seed. If this happens, direct reuse of the seed value would be unacceptable because the key generation algorithm may not then be able to complete its computation, as it may not find any value to output that satisfies all test criteria. Use of the dynamically seeded pseudorandom number generation algorithm avoids this potential infinite cycling problem by ensuring the availability of an arbitrary number of pseudorandom bits.

```sequence
random number generator -> key generation algorithm
Note right of key generation algorithm: verify the mathematical property
key generation algorithm -> cryptographic algorithm
```

FIG. 7 is a flow diagram illustration of key generation algorithm 151 when cryptographic algorithm 150 is the RSA algorithm. Key generation algorithm 151 produces a public and private key pair PU =(e,n) and PR =(d,n), where e and d are called the public and private exponents (e and d are positive integers less than n) and n is the public modulus. Thus, in the 2-tuple (d,n), only the private exponent d needs to be kept secret. Refer ring now to FIG. 7, at step 161 a trial value of p is generated. At step 162, the value of p is tested for primality. A method for primality testing is described below. If p is prime, control passes to step 163; otherwise control passes back to step 161 (i.e., a new p is generated). At step 163, p is tested to see whether it is a ¡°strong¡± prime. The term ¡°strong¡± prime is a term used within the art to denote a prime p that satisfies a set of additional criteria that ensures that the selected value of p does not permit certain mathematical analysis to be performed in order to "break¡± the cryptographic algorithm by factoring the modulus n into its primes p and q. See Rivest, R. L, Shamir, A., and Adleman, L., ¡°A Method for Obtaining Digital Signatures and Public Key Cryptosystems,¡± Communications of the ACM, 21, No. 2, 120-126, 1978, for a discussion of key generation and extra tests that can be performed on p and q to ensure they are strong enough to thwart cryptographic attacks. The additional tests performed on p at step 163 consist of testing that p--1 has a large prime factor p¡¯ and that p'¡ªl has a large prime factor p¡±. Another test suggested within the literature describing RSA key generation is to test that p+1 has a large prime factor.  If p is a ¡°strong" prime, control passes to step 164; otherwise control passes back to step 161 (i.e., a new p is generated). At step 164 a trial value of q is generated.  At step 165, the value of q is tested for primality. A method for prirnality testing is described below. If q is prime, control passes to step 166; otherwise control passes back to step 164 (i.e., a new q is generated). At step 166, q is tested to see whether it is a ¡°strong¡± prime.  The additional tests performed on q at step 166 consist of testing that q-l has a large prime factor q¡¯ and that q'-¡ª1 has a large prime factor q". Another test suggested within the literature describing RSA key generation is to test that q+l has a large prime factor. If q is a ¡°strong¡± prime, control passes to step 167; otherwise control passes back to step 164 (i.e., a new q is gener ated). At step 167, the public modulus n is formed as the multiplicative product of p and q. At step 168, the value r is formed as the multiplicative product of (p- l) and (q- 1). At step 169, the key generation algorithm determines whether a public exponent e has been supplied as an input. If so, then control passes to step 172, and it is assumed that the supplied value of e satisfies the condition tested at step 171. An alternate embodiment, control could flow to step 171 and the supplied value of e could be checked by key generation algorithm 151. If not, then control passes to step 170. At step 170 a trial value of e is generated. At step 171, e is tested to ensure that it is relatively prime to r. This is easily accomplished to checking that the greatest common divisor (GCD) of e and r is l, i.e., e and r have no factor in common except 1. If e and r are relatively prime to each other, then control passes to step 172; otherwise, control passes back to step 170 (i.e., a new value of e is generated). At step 172, the value d is calculated so that the product of e and d is congruent to l modulo r. At step 173, the calculated values of PU=(e,n) and PR=(d,n) are returned as outputs.

One suitable technique for testing large numbers for primality is to use the efficient "probabilistid¡¯ algorithm described by R. Solovay and V. Strassen in their letter entitled ¡°A Fast Monte-Carlo Test for Primality¡± SL4M Journal on Computing, March 1977, pages 84 and 85. It picks a random number ¡°a¡± from a uniform distribution (1, 2, . . . , x- l) and tests whether the greatest common divisor of ¡°a¡± and x is l, i.e., GCD(a,x)= l, and whether the Jacobi symbol of ¡°a¡± and x, denoted J(a,x), is congruent to Q modulo x, where Q is equal to ¡°a¡± raised to the power (x- l)/2. The number x can now be tested for primality by using a set of integers (al, a2, etc.) where each ¡°a¡± in the set is less than it. Note that the value x is replaced by the values p and q when generating RSA keys, as illustrated in FIG. 7. The test requires that, for each value of ¡°a¡± in the set, that both conditions stated above hold. Thus, x is found to be a composite number if there is an ¡°a¡± in the set for which the two conditions do not hold; otherwise x is accepted as prime. The procedure does not guarantee that a selected number is prime, but only that it has not failed the test of primality. The greater the number of integers ¡°a¡± in the set (al, a2, etc.), the greater the probability that a selected number is prime-assuming of course that both conditions are satisfied for each of the integers ¡°a¡± in the set. Methods for calculating the greatest common divisor of two integers, the least common multiple of two integers, and the Jacobi symbol of two integers are well known within the art.

It is well-known to those skilled within the art, that for the RSA algorithm to achieve adequate cryptographic security, it is necessary for the modulus n to be a number somewhere between 512 and 1,024 bits. In the described key generation algorithm, the public key exponent e can either be speci?ed to the key generation algorithm or it can be generated by the key generation algorithm. The advantage in specifying e to the key generation algorithm is that a small value can be speci ?ed, say e=3. This gives improved performance when encrypting with the public key. The private exponent d is a dependent variable, and must be derived. Hence, for practical purposes,d will be of the same size as the modulus. Thus, one sees that for a modulus of 512 bits, the public key PU will have from 514 to 1,024 bits, depending on the number of bits in the selected exponent e, whereas the private key PR will have 1,024 bits.  When compared to DEA keys which are 64 or 128 bits, the RSA keys are considerably larger. Those skilled in the art will also recognize that key generation with a public key algorithm is a fairly computationally intensive procedure. Thousands and perhaps even millions of DEA keys can be generated in the same time it takes to generate a single public and private key pair. Unlike the DEA which has a fixed block size, the RSA algorithm does not specify a particular block size. This accounts for the fact that RSA key generation may be a relatively short or relatively long process, depending on the selected modulus length. In order for the key generation algorithm 151 to generate public and private keys of a desired size (i.e., with a specified number of bits), steps 161 and 164 are designed so that the generated primes p and q, when multiplied together, will produce a modulus n of desired size, or length in bits. Those skilled in the art will appreciate that additional tests on p and q can be added to the flow diagram in FIG. 7, so that key generation can be tailored according to specifications that may be provided within a cryptographic standard, such as ISO Draft Internal Standard 9796 ¡°Digital Signatures Scheme Giving Message Recovery.¡± Those skilled in the art will also recognize that **the RSA key generation algorithm described in FIG. 7 could be made more efficient** if p and q are produced with a process that combines trial and error with a method that constructs the values, instead of using only a trial and error I process. Instead of generating p, testing that p-l has a large prime p¡¯, and testing that p¡¯¡ª1 has a large prime p", one could start by generating a large prime p". In that case, one finds a prime p¡¯ from p" by multiplying p" with a small number, adding one, and then testing for primality. If the resulting p¡¯ is not prime, then repeat the process, except multiply p" by a different small number. The valve of p can be found from p¡¯ using the same technique. Likewise, q can be found from q" using the same technique.

Random and Pseudorandom Numbers: Most cryptographic systems require a means to produce and use random numbers. Random numbers are used as keys or in the production of keys. Random numbers are used as initialization vectors or initial chaining values, e.g., when using the Cipher Block Chaining mode of encryption with the DEA. Random numbers are used as ¡°seed¡± values, e.g., when using the Cipher Feedback mode of encryption with the DEA. Random numbers are used as nonces in many cryptographic-based identification and authentication protocols. Without a capability to produce random numbers, most cryptographic systems would be severely limited or rendered useless.

----

FIGS. 8 and 9 illustrate the two frequently used means to generate random numbers within cryptographic systems. FIG. 8 is a block diagram illustration of a ¡°true¡± random number generator 180. ¡°True¡± random number generator 180 contains a hardware circuitry 181, which is capable of producing random numbers. Means for producing random numbers with such hardware generators is well known and practiced within the art (see U.S. Pat. No. 4,905,176 ¡°Random Number Generator Circuit,¡± by R. Schulz, issued Feb.  27, 1990, cited above). Requests for random numbers are input via interface 182. Generated random numbers (RNl, RNZ, etc.) are output via interface 183. In practice, the length of the generated random numbers is a fixed constant of the algorithm, e.g., 64 bits. A ¡°true¡± random number generator has the property that its output values are unpredictable. That is, no algorithm can be constructed that will predict the output of the random number generator. A ¡°true¡± random number generator requires no seed value to initialize it, and hence there is no way to force the outputs of the generator to repeat. These properties make the ¡°true¡± random number generator highly desirable for implementation within cryptographic systems. However, the cost of ¡°true¡± random number generators is relatively high when compared to pseudorandom number generators, and therefore, most commercial cryptographic systems use pseudorandom number generators.

FIG. 9 is a block diagram illustration of an initially seeded pseudorandom number generator 190. Initially seeded pseudorandom number generator 190 contains an algorithm 191 and a seed storage 194 for the storage of a seed value used by algorithm 191 to generate random numbers. (Note that the random numbers produced by a pseudorandom number generator only appear random. More correctly, the output produced by a pseudorandom number generator should be called pseudorandom numbers. But for convenience, we shall call them random numbers.) The seed value is specified via interface 195. The initial seed value itself may be input to the cryptographic system via a utility program that interfaces to the cryptographic facility via one of the cryptographic instructions, or it may be input via a special front panel interface that may be activated only by authorized installation personnel using an entered password or a physical key-activated switch.  When a pseudorandom number generator is used for generating keys, the initial and all subsequent seed values must be kept secret. Otherwise, since the pseudorandom number generation algorithm is considered to be in the public domain, **the secrecy of the generated random numbers depends on keeping the seed values secret**.  When random numbers are generated, the seed value may be updated dynamically by algorithm 191, depending on the nature of algorithm 191. Algorithm 191 may also contain a separate storage, such as a storage for a counter or sequence number which is automatically updated during the production of random numbers. In this case, the seed value may remain constant and only the counter or sequence number is updated.

In cases where a counter or sequence number is used, its initial value is set by the algorithm 191 at the time the seed value is initialized via interface 195 into seed storage 194. Requests for random numbers are entered via interface 192. Generated random numbers (RN 1, RN2, etc.) are output via interface 193. In practice, the length of generated random numbers will be some fixed value, e.g., 64 bits. A pseudorandom number generator has the property that its output values are entirely predictable. The output of a pseudorandom number generator is a stream of numbers (RNl, RN2, etc.) which appear random. RN2 differs from RN1 only because the algorithm has a "memory", so to speak. That is, the algorithm update itself continually, so that each time the algorithm is called it begins from a different "starting" point. However, if each instance of the same algorithm were initialized with the same seed value, then the random number produced by each algorithm 191 would be exactly the same. Good cryptographic practice dictates that the initial seed value should itself be selected via a random process. This ensures that each initially seeded pseudorandom number generator 190 in each differenet cryptographic device will produce different random numbers.

FIG. 10 is a block diagram illustration of a dynamically seeded pseudorandom number generator 200. Dynamically seeded pseudorandom number generator 200 contains an algorithm 201 for generating random numbers. Requests for random numbers are entered via interface 202. Generated random number (RNl, RN2, etc.) are output via interface 203. The length of the generated random number, designated RN, at interface 203 is equal to the value specified by the length parame ter at interface 202. Algorithm 201 has no internally stored seed value. Instead, the required seed value is specified to algorithm 201 at interface 202. Note that this seed value must be externalized to the invoker, as this allows interleaving of requests by other invokers, while ensuring the same output will result when the same seed is input. For convenience, algorithm 201 also permits a length parameter to be specified at interface 202, where the value of length determines the length of the generated random number. In practice, the length of the seed would most likely be a fixed constant pre-established by algorithm 201. To illustrate the operation of dynamically seeded pseudorandom number generator 200, assume the following: 
1. the parameter ¡°length¡± is specified in bits, 
2. ¡®the length in bits of the parameter ¡°seed¡± is 128, and L is the length in bits of the desired random number, which is designated RN. 

In that case, value specified in parameter ¡°length¡± is calculated as 128+L, i.e., the length of the next seed plus the length of the desired random number.

In an alternate embodiment, the production of the next seed could be made automatic, and hence parame ter ¡°length¡± would specify the length of the desired random number RN. In that case, there are two outputs at interface 203, next seed and RN.

Either embodiment will work. In the first case, dynamically seeded pseudorandom number generator 200 is unaware of the method for producing next seed. The production and management of the next seed value is under the control of the invoker. In the second case, dynamically seeded pseudorandom number generator M is responsible for calculating and returning a next seed value to the invoker.

In another alternate embodiment, **the algorithm for the initially seeded pseudorandom number generator and the algorithm for the dynamically seeded pseudorandom number generator could be the same algorithm**, and the same circuitry and/or routines for the algorithm could be used. The initially seeded generator would use system storage that is not accessible to a normal user to contain the system seed values, which would be automatically updated as needed when the initially seeded algorithm was invoked, and the dynamically seeded generator would require the invoker to pass (and there fore maintain) the seed values. Those skilled in the art will appreciate that many embodiments with one or more minor modifications and variations from the de scribed methods are possible, and that these differences have no impact on the invention.

The reader will appreciate that in order to practice the subject invention, wherein a public and private key pair (PU,PR) is generated from a secret passphrase supplied as input by the user, it is of critical importance for the key generation algorithm to be able to regenerate the same sequence of random numbers and therefore to re-generate the same key pair (PU,PR) each time the same passphrase is specified to the key generation algorithm. **In contrast to this, all other cryptographic applications requiring random numbers within a cryptographic system have no need to re-generate the same sequence of random numbers**. In fact it could be argued that such a capability, if present within the cryptographic system, might lead to an unfortunate situation wherein keys are accidentally re-generated.

> probabilistic -> most cryptographic system
> deterministic -> present invention

----

From the foregoing discussion, it is evident that the dynamically seeded pseudorandom number generator illustrated in FIG. 10 can satisfy the requirements of the present invention, but does not satisfy the general requirement for production of random numbers within most cryptographic systems. Likewise, from the foregoing discussion, it is evident that the ¡°true" random number generator illustrated in FIG. 8 and the initially seeded pseudorandom number generator illustrated in FIG. 9 can satisfy the general requirement for production of random numbers within most cryptographic systems, but do not satisfy the requirement for production of random numbers when the key generation algorithm must re-generate keys from a passphrase. Therefore, in the preferred embodiment of the invention, two means for generating random numbers shall be required, as illustrated in FIG. 11. Referring to FIG. 11, the cryptographic algorithms 144 component of the cryptographic facility, previously depicted in FIG. 6, has been expanded to include a dynamically seeded pseudorandom number generator 200 and interface 204 between key generation algorithm 151 and dynamically seeded pseudorandom number generator 200 permitting requests for random numbers to be made and generated random numbers to be returned. Dynamically seeded pseudorandom number generator 200 in FIG. 11 is assumed to operate the same as dynamically seeded pseudorandom number generator 200 in FIG. 10, already described. That is, a request for a random number also includes the specification of a length and a seed. The output is a random number. The key generation algorithm 151 is assumed to manage the seed values. For example, the first seed is calculated from the passphrase using a method yet to be described. Whenever key generation algorithm 151 requires a random number of length L, it specifies a ¡°length¡± parameter of L+ I28, i.e., it automatically requests a next seed which it saves in a next seed storage area accessible to key generation algorithm 151 (e.g., within key generation algorithm 151). In the situation where key generation algorithm 151 of FIG. 11 is just the RSA key generation algorithm 151 of FIG. 7, steps 161, 164, and 170 of FIG. 7 would result in requests for random numbers directed to dynamically seeded pseudorandom number generator 200 at interface 204 of FIG. 11. Thus, each time step 161, 164, or 170 of FIG. 7 is repeated, a new random number is obtained. And since there is no way to know in advance how many trials are needed before finding values that are satisfactory, since the process is one of trial and error, one cannot pre-calculate the sequence of random numbers and use them as required.  

FIG. 12 is an example of a dynamically seeded pseudorandom number generator that satisfies the requirements of the present invention. The algorithm requires a 128-bit seed which is divided into a 64-bit key K and a 64-bit initial chaining value ICV.. The leftmost 64 bits of seed becomes K and the rightmost 64 bits of seed becomes ICV. If m is the number of random bits to be generated, then let 64n denote the smallest value larger than m. Note that n represents the number of 64-bit blocks of to-be-generated ciphertext which is long enough to produce a pseudorandom sequence of m bits.  To generate the ciphertext, we start with n 64-bit blocks of binary zeros, which are encrypted with the DEA algorithm using the Cipher Block Chaining mode of DEA encryption. The key and initial chaining value are just the values K and ICV mentioned above. The output random number RN of length m is just the leftmost (most significant) m bits in the resulting ciphertext.

Key Generation Using a Passphrase: FIG. 13 illustrates a cryptographic system comprising a cryptographic facility (CF) 30, a cryptographic key data set (CKDS) 32, a cryptographic facility access program (CFAP) 34, and application programs (APPL) 36. Referring now to FIG. 13, the steps in generating a public and private key pair (PU,PR) can be traced. Application program A (APPL A) 42 is invoked by a user at 40.  APPL A is assumed to be (1) an application that requires the user to generate or re-generate his keys before the application can continue with processing, or (2) it is a utility that permits users to generate or re-generate their keys. APPL A prompts the user for his/her passphrase (designated PP), which the user enters at 41.  In response, APPL A calls KEY GENERATE function 47, at 43, located in the CFAP 34, passing a mode parameter, PP, and control information (designated control information). *The control information* may be control vectors or information used to build the control vectors. *The mode parameter* indicates to the KEY GENERATE function whether the generate keys are to be generated on the basis of a passphrase (mode=¡®PP¡¯), or not (mode=¡®noPP¡¯). The PP parameter is therefore an optional parameter. The control information is key-related information specifying key type (i.e., the type of public and private key pair to be generated) and usage control information indicating how the keys can be used within the key management. In response,
KEY GENERATE function 47 (l) parses the input
parameters, (2) calculates a 128-bit hash value CW from
the input passphrase PP if mode=¡®PP¡¯, processes the
input control information and builds the control data
parameters to be speci?ed to the GPUPR instruction,
and (3) invokes the GPUPR instruction 52 executing in
instruction processor 142 of cryptographic facility 30 at
50, passing a mode parameter, an optional code word
CW, if mode=¡°PP¡±, and control data. The control data
consists of a PU control vector specifying key-related
information associated with and about the tobe
generated public key PU and a PR control vector speci
fying key-related information associated with and about
the to-be-generated private key PR. Each control vec
tor contains a key name identifying the key within the
cryptographic system. Each control vector may also
contain a label, or reserved space for a CKDS label to
be






 


























