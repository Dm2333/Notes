
##动态规划

1. LCS 最长公共子序列

    对于序列A[0, n]和B[0, m], LCS(A, B)无非三种情况
    - 若n=-1或m=-1, 则取作空序列(递归基)
    - 若A[n]='X'=B[m], 则取作LCS(A[0, n), B[0, m))+'X'
    - 若A[n]!=B[m], 则在LCS(A[0, n], B[0, m))与LCS(A[0, n), B[0, m])中取最长者
    - 采用动态规划的策略, 将所有子问题列出表格, 颠倒计算方向, 从LCS(A[0], B[0])出发依次计算出所有项


##有序列表

1. 唯一化

    顺序遍历, 并删除与上一个遍历元素相同的节点
    
2. 查找p的n个前去中, 找到不大于e的最后者
   
   向前遍历, 如果正在遍历的元素已经小于等于e或超出n个元素, 则返回
   

##选择排序

找到列表中最大值, 将其交换对象到列表最末尾

Bubble sort也是一种选择排序, 但开销太大, worst-case都需要O(n^2), 其效率低下的主要原因在于, 每次选择出的最大元素, 都只能一步一步移动到列表最后端.

new&delete的时间代价大致是其他常量操作的100倍, 所以应当尽量避免

##插入排序

###平均性能

backward Analysis

插入序列在插入时, 就是计算当前插入元素的inversion(逆序对)数量. 其中某个元素的逆序对数量为所有逆序对中, 以这个元素为逆序对后值的个数. 因此插入排序的代价为O(I+n), 其中I代表列表中逆序对个数. Input-sensitive!

1. 最好情况, 即正序输入的情况下, 逆序对数量为0, 其花销为O(n)
2. 最坏澄清, 即逆序输入的情况下, 逆序对数量为(0+n)*n/2, 其花销为O(n^2)

#4. 栈和队列

##栈接口与实现

push, size, empty, pop, top

经典应用:
1. 逆序输出

    conversion
    输出次序与处理次序颠倒, 递归深度和输出长度不易预知
3. 递归嵌套

    stack permutation+parenthesis
    具有自相似性的问题可递归描述, 但分支位置和嵌套深度不固定
1. 延迟缓冲

    evaluation
    线性扫描算法中, 在预读足够长之后, 方能确定可处理的前缀
1. 栈式计算

    RPN
    基于栈结构的特定计算结构

栈的应用:
1. 进制转换

    进制转换需要不断除去某一个进制数得到一系列余数, 并将余数产生的顺序逆转以得到转换后的进制表达
2. 括号匹配

    顺序扫描表达式, 用栈记录已扫描部分的左括号, 如果遇到一个右括号, 则将栈中上一个左括号pop出来. 单一括号类型可以使用计数器, 但多重括号类型则不能使用计数器

3. 栈混洗

    将栈A的顶元素弹出并压入栈S, 或将S的顶元素弹出并压入栈B中. 经过前面若干次操作, A中元素全部转入B中后, B则称之为A的一个栈混洗( stack permutation )
    
    对于具有n个元素的栈, 其栈混洗个数为catalan数, 即(2*n)!/(n+1)!/n!, 其计算过程为:
    
    \begin{equation*}
    当A中栈顶元素作为B中第k个元素被推入栈B时, 栈S为空. 栈A中剩余元素为原来的最后n-k个, 而栈B中元素为k-1个已被压入元素+栈顶元素, 因此两者子序列相互独立.
    SP(n)=\sum_{k=1}^nSP(k-1)*SP(n-k), SP(1)=1
    \end{equation*}
    
    栈混洗甄别则可以根据判断序列中是否包括[... 3 ... 1 ... 2 ...]这样相对次序的序列(不需要元素互相紧邻), 如果包含则不是栈混洗, 否则便是栈混洗.
    1. 对于任意i<j 不含模式[..., j+1, ..., i, ..., j, ...], 可得到一个O(n^2)的甄别算法
    2. 直接借助栈A, B和S, 模拟栈混洗过程, 采用贪心原则将A转入B, 只要这一过程能顺利的进行, 每次S.pop时S已经变空, 或者需要弹出的元素在S中, 但并非顶元素, 则可以判断该栈混洗是非法的

4. 栈混洗与括号匹配

    栈混洗的过程, 都对应于栈S的n次push和n次pop操作构成的序列, 如果把相同元素的pop和push看为一组括号, 那么栈混洗刚好就是括号匹配的过程.
    
    同理, 任何合法的括号匹配表达式, 都代表着一种栈混洗方案

5. 中缀表达式求值

    运算数, 运算符双栈
    比较运算符优先级可以使用一张二维运算符优先级表格, 若当前运算符优先级低于栈顶运算符, 则根据其是一元运算符/二元运算符讲运算数栈中的内容弹出进行计算, 计算结果压入运算数栈中

6. 逆波兰表达式

    RPN,Reverse Polish Notation
    在不适用括号的情况下, 即可表示带优先级的运算关系






