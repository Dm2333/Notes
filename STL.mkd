
#STL Introduction

##六大组件

1. 容器

    各种数据结构, 用来存放数据
2. 算法

    各种例如sort, search的常用算法
3. 迭代器

    容器和算法的胶合器, 是所谓的泛型指针
4. 仿函数

    行为类似函数, 可作为算法的某种策略. 实现上来说, 是一种重载了operator()的class或class template
5. 配接器

    修饰容器或仿函数的或迭代器的东西.
6. 配置器

    负责空间配置和管理


#C Standard library:STL

##<errno.h>/<cerrno>

errno.h 是C语言C标准函式库里的标头档，定义了通过错误码来回报错误资讯的宏：  
errno宏定义为一个int型态的左值, 包含任何函式使用errno功能所产生的上一个错误码。  

----

##<stdio.h>/<cstdio>

###printf

####转换说明符 

- `%a`      浮点数、十六进制数字和p-记数法（Ｃ９９）  
- `%A`　　　浮点数、十六进制数字和p-记法（Ｃ９９）  
- `%c`　　　一个字符　  
- `%d`　　　有符号十进制整数　  
- `%e`　　　浮点数、e-记数法  
- `%E`　　　浮点数、Ｅ-记数法  
- `%f`　　　浮点数、十进制记数法　　  
- `%g`　　　根据数值不同自动选择％f或％e．  
- `%G`　　　根据数值不同自动选择％f或％e.  
- `%i`      有符号十进制数（与％d相同）  
- `%o`　　　无符号八进制整数  
- `%p`　　　指针　　　　  
- `%s`　　　字符串  
- `%u`　　　无符号十进制整数  
- `%x`　　　使用十六进制数字０f的无符号十六进制整数　  
- `%X`　　　使用十六进制数字０f的无符号十六进制整数  
- `%%`　　　打印一个百分号  
- `%n`      The corresponding argument must be a pointer to a signed int.

        `sscanf(str, "0x%x%n", &a, &b);`
        `printf("blah %n blah \n", &val); printf("val=%d\n", val);`

----

####长度修饰符 

常用的长度修饰符有两种：

1. l（长）表示按长整型量输出
1. h（短）表示按短整型量输出。

> 可以和输出转换说明符d、f、u等连用

----

####宽度修饰符和精度修饰符 

宽度修饰符用来指定printf（）函数输出数据的占位宽度，用一个十进制整数表示输出数据的位数，插在百分号%与转换说明符之间，其作用是控制打印数据的宽度，也称为“域宽”。

也可以在prinf函数中指定输出数据的精度。以一个小数点开始，后紧跟着一个十进制整数表示精度，插在百分号%与转换说明符之间。对于不同数据类型，精度的含义也不相同：在使用%d时，精度表示最少要打印的数字的个数。在使用%f、%e、%E时，精度是小数点后面显示的数字个数。在使用%s时，精度表示输出的字符串中字符的个数。


1. %md

    以宽度m输出整型数，不足m位数时左侧补以空格。 

1. %0md

    以宽度m输出整型数，不足m位数时左侧补以0（零）。 

1. %m.nf

    以宽度m输出实型数，小数位数为n位。 

1. %ms

    以宽度m输出字符串，不足m位数时左侧补以空格。 

1. %m.ns

    以宽度m输出字符串左侧的n个字符，不足m位数时左侧补以空格。

----

####标志修饰符 

在printf 函数中，可以使用标志修饰符控制输出格式。

- `-`

    “左对齐”方式：输出数据左对齐，右侧补空格。缺省时输出数据则为右对齐，左补格。 

- `+`

    输出数据为正时，在数据之前显示一个+号，为负时，在数据之前显示一个-号。 

- `#`

    输出数据为八进制时加前缀0，为十六进制时前缀0x。 

- `空格`

    输出数据为正值时，在数据之前打印空格，为负时，数据之前显示一个-号。

----




##<memory>

###auto_ptr

auto_ptr是这样一种指针：它是“它所指向的对象”的拥有者。这种拥有具有唯一性，即一个对象只能有一个拥有者，严禁一物二主。当auto_ptr指针被摧毁时，它所指向的对象也将被隐式销毁，即使程序中有异常发生，auto_ptr所指向的对象也将被销毁。

----

关于auto_ptr的几种注意事项：

1. auto_ptr不能共享所有权。
2. auto_ptr不能指向数组
3. auto_ptr不能作为容器的成员。
4. 不能通过赋值操作来初始化auto_ptr

        std::auto_ptr<int> p(new int(42));     //OK
        std::auto_ptr<int> p = new int(42);    //ERROR
    这是因为auto_ptr构造函数被定义为explicit

5. 不要把auto_ptr放入容器

> 智能指针通过RAII来确保内存资源的安全，也间接地使得对象上的RAII得到实施

> 这里的RAII并不是十分严格：对象（所占的内存也是资源）的创建（资源获取）是在构造函数之外进行的。广义上，我们也把它划归RAII范畴。

> Matthew Wilson在《Imperfect C++》一书中，将其独立出来，称其为RRID（Resource Release Is Destruction）。

----

auto_ptr对象间的赋值是一个需要特别注意的地方。简单说来资源代理对象间赋值的语义不满足“赋值相等”，其语义是资源管理权的转移。

    int a;  int b = 10;  a = b; //这句话执行后 a == b 但对于资源代理对象，这是不满足的，比如：
    auto_ptr<int> a(null);  auto_ptr<int> b(new int(123));  a = b; //这句话执行后a != b，赋值的语义是b把资源的管理权交给了a 

****



