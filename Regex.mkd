
#正则模式与匹配模式

1. 不区分大小写的匹配模式
1. 宽松排列与注释模式

    此模式会忽略字符组外部的所有空白字符. 字符组内部的空白字符仍然有效, `#`与换行符之间的内容会被视为注释
1. 点号通配模式 ( dot-match-all match mode ), 单行模式

    通常, 点号是不能匹配换行符的. 对于现代编程语言来说, 点号能够匹配换行符的模式和不能匹配的模式同样有用. 许多程序提供了两种方法供正则表达式选择.
1. 增强的行锚点模式 ( Enhanced line-anchor match mode, 也叫多行文本模式 )
1. 文字文本模式

    文字文本模式几乎不能识别任何正则表达式元字符. 完整的字符文字搜索等于见得的字符串搜索.  

    正则表达式的文字文本模式之所以更有趣, 是因为她可以只作用于正则表达式的一部分.


#正则语法

##字符表示法

1. 字符缩略表示法
1. 八进制转义

    `\015\012`匹配ASCII的CR/LF序列
1. 十六进制/Unicode转义

    `\x0D\x0A`匹配ASCII的CR/LF序列
1. 控制字符

    `\cJ`匹配ASCII的\n, `\cM`匹配ASCII的\r

----

##字符组及相关结构

1. 普通的字符组
1. 点号
1. 单个字节: `\C`
1. Unicode组合字符序列: `\X`
1. 字符组简记法: `\w \d \s \W \D \S`
1. Unicode属性, 区块和分类: `\p{Prop}, \p{Prop}`
1. 字符组运算符: `[[a-z]&&[^aeiou]]`
1. POSIX字符组方括号表示法: `[[:alpha:]]`
1. POSIX "collating序列" 方括号表示法: `[[.span-11.]]`
1. POSIX "字符等价类" 方括号表示法: `[[=n=]]`

----

##锚点及其他零长度断言
1. 行/字符串起点
1. 行/字符串重点
1. 本次匹配的开始位置
1. 单词分界符
1. 顺序环视, 逆序环视

----

##注释和模式修饰符
1. 模式修饰词
1. 模式作用范围
1. 注释
1. 文字文本范围

----

##分组, 捕获, 条件判断和控制
1. 捕获/分组括号
1. 仅用于分组的括号
1. 命名捕获
1. 固化分组
1. 多选结构
1. 条件判断
1. 匹配优先量词
1. 忽略优先量词
1. 占有优先量词

****

#表达式的匹配原理

##正则引擎分类
1. DFA ( 符合或不符合POSIX标准的都属此类 )
1. 传统型NFA
1. POSIX NFA

----

##测试引擎类型
1. 是否支持忽略优先量词

    如果支持, 基本确定是传统型NFA
1. 用正则`nfa|nfa not'来匹配字符串'nfa not'

    如果只有nfa匹配, 就是传统NFA, 否则, 则是POSIX NFA或者DFA
1. 用`X(.+)+x`匹配形如'=XX==============================='这样的字符串

    如果执行话很长时间, 就是NFA. 
    时间很短, 就是DFA, 或是支持高级优化的NFA.
    DFA不支持捕获型括号和回溯

----

##规则1 优先匹配最左端

----

##规则2 标准量词是匹配优先的

----

###先来先服务

`^.*[0-9]+`这样的表达式, 匹配'Copyright 2003'这样的字符串时, `.*`会匹配到'Copyright 200'
对于`[0-9]+`来说, 回溯一次, 匹配到'3'就已经条件满足. 不会回溯到'2003'

----


##NFA

表达式主导
正则引擎每次查看表达式的一部分. 如果匹配, 则继续表达式的下一部分. 直到表达式的所有部分都能匹配, 即真格表达式能够匹配成功

在表达式主导的匹配过程中, 每一个子表达式都是独立的. 子表达式之间不存在内在联系, 而只是整个正则表达式的各个部分.

----

##DFA
文本主导
在扫描字符串时, 会记录当前有效的所有匹配结果. 接下来扫描的每个字符, 都会更新当前的可能匹配序列.
扫描的字符串中每一个字符都对引擎进行了控制.

----

##NFA vs DFA

NFA 非确定型有穷自动机
DFA 确定性有穷自动机

----

##回溯

NFA引擎最重要的性质是, 会依次处理各个子表达式或组成元素, 遇到需要在两个可能成功的可能中进行选择时, 它会选择其中一个, 并记住两一个, 以备稍后的可能

需要作出选择的情景包括:
1. 量词 ( 决定是否尝试另一次匹配 )
2. 多选结果 ( 决定选择哪个多选分之, 留下哪些稍后尝试 )

----

###回溯两个要点
1. 如果需要在**进行尝试**和**跳过尝试**之间选择, 对于匹配优先量词, 引擎会优先选择**进行匹配**, 而对于忽略优先匹配量词, 会选择**跳过尝试**
1. 距离当前最近存储的选项就是当本地失败强制回溯时返回的, 使用的原则是LIFO.

----





































