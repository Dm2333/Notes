
#Introduction

Current malware tools disguise themselves by making use of obfuscation techniques designed to frustrate any efforts to dissect or reverse engineer the code.  

Advanced code engineering can even cause malware to behave differently if it detects that it is not running on the system for which it was originally targeted. 

To combat these defensive techniques, this paper presents a sandbox-based environment that aims to accurately mimic a vulnerable host and is capable of semi-automatic semantic dissection and syntactic deobfuscation of PHP code.

The novel technique of performing deobfuscation based on the identification and reversal of common obfuscation idioms proved highly effective in revealing hidden code.

#Backgournd and Previous Work

##Code Obfuscation

All methods of code obfuscation can be evaluated according to three metrics [38]:
- Potency 每 the extent to which the obfuscated code is able to confuse a human reader
- Resilience 每 the level of resistance to automated deobfuscation techniques
- Cost 每 the amount of overhead that is added to the program as a result of the transformation

1. layout
1. data
1. control obfuscation

##Code Obfuscation and PHP

    eval(gzinflate(base64 decode($str)))

Although seemingly complex, code obfuscated in this manner can easily be neutralised and analysed for potential backdoors

Replacing the eval() function with an echo command will display the code instead of executing it, allowing the user to determine whether it is safe to run. This process can be automated *using PHP＊s built-in function overriding mechanisms*.

##Deobfuscation Techniques

The obfuscation methods described in the previous sections are all designed to prevent code from being reverse engineered.

Bearing this in mind, it is useful to review the techniques that are widely employed by existing deobfuscation systems:

- Pattern matching 每 the detection and removal of known bogus code segments
- Program slicing 每 the decomposition of a program into manageable units that can then be evaluated individually
- Statistical analysis 每 the replacement of expressions that are discovered to always produce the same value with that value
- Partial evaluation 每 the removal of the static part of the program so as to evaluate just the remaining dynamic expressions

##Code Dissection

The process of analysing the behaviour of a computer program by examining its source code is known as code dissection or semantic analysis

The main goal of the dissection process is to extract the primary features of the source program, and, in the case of malicious software, to neutralise and report on any undesirable actions [42].

##Static Dissection Techniques

Static analysis approaches attempt to examine code without running it [44]. Because of this, these approaches have the benefit of being immune to any potentially malicious side effects. 

The lack of runtime information such as variable values and execution traces does limit the scope of static approaches

1. Signature Matching:

    comparing the signature of an unknown program to a large database containing the signatures of all known malware 

1. Pattern Matching:

----

##Dynamic Dissection Techniques

Dynamic approaches to analysis extract information about a program＊s functioning by monitoring it during execution

1. API Hooking:

    This is achieved by altering the code at the start of the function that the program has requested access to before it actually accesses it and redirecting the request to the user＊s own injected code [47].
    The request can then be examined to determine the exact behaviour exhibited by the program before it is directed back to the original function code [46]

    The precision and volume of code required for correct API hooking mean that behaviour monitoring systems that make use of the technique are complex and time consuming to implement [47].
1. Sandboxes and Function Overriding

    A sandbox is a restricted programming environment that is used to separate running programs [48]. Malicious code can safely be run in a sandbox without affecting the host system, making it an ideal platform for the observation of malware behaviour [49].
    PHP＊s Runkit extension contains the Runkit Sandbox class, which is capable of executing PHP code in a sandbox environment [50].

    - The safe mode include dir option can be used to specify a single directory from which modules can be included in the sandbox.
    - The open basedir option can be used to specify a single directory that can be accessed from within the sandbox.
    - The allow url fopen option can be set to false to prevent code in the sandbox from accessing content on the Internet.
    - The disable functions and disable classes options can be used to disable any functions and classes from being used inside the sandbox.

****

#DESIGN AND IMPLEMENTATION

The development of a system capable of analysing PHP shells required the design and construction of two main components: the **decoder** and the **sandbox**.

##Scope and Limits

The closer coupling between the components and the feedback mechanisms allows *information relating to each stage in the process of shell analysis to be relayed to the user as it occurs*每 deobfuscation results are displayed during static analysis, and *the results of executing the shell in the sandbox environment are displayed during dynamic analysis*

----

##Architecture, Operating System and Database

A core part of the system is the sandbox environment, which is designed to safely execute potentially malicious PHP code.  This component relies heavily on the Runkit Sandbox class that forms part of PHP＊s Runkit extension package [50]. 

1. This component relies heavily on the Runkit Sandbox class that forms part of PHP＊s Runkit extension package [50].
1. Ubuntu (version 12.10) was chosen because of its familiarity and status as the most popular (and therefore most widely supported) Linux distribution
1. VMware Player is used to run an Ubuntu host in a virtual machine environment.  
1. Both the decoder and the sandbox components make use of a MySQL database for the persistent storage of web shells. 

    PHP scripts being analysed are stored by computing the MD5 hash of the raw code and using the resulting 32-bit string as the primary key. Each MD5 hash is then checked against the previously analysed code stored in the database to prevent duplication. Once the shell has been decoded, the resulting deobfuscated and normalised version of the code is stored alongside the hash and the raw code in the database. This deobfuscated code is what is then executed in the sandbox environment. 
    ![webshell_sandbox_workflow](./img/Webshell/webshell_sandbox_workflow.png)

----

##Web Server Sandbox

advanced scripts fail to begin executing at all if they do not detect an HTTP server and its associated environment variables [53, 9].  The system was thus designed to closely mimic conditions that might be found on a real world web platform to facilitate correct shell execution and allow analysis to take place.

In pursuit of this goal, an Apache HTTP server was installed inside the virtual machine.

###Choice of Apache

1. Firstly, as was the case with Ubuntu, many installation and configuration guides are available for Apache.
1. Secondly, Apache＊s popularity means that it is also well supported by the developers of web shells

###Apache Compilation and Configuration

As has already been stated, it was necessary to compile Apache from the source to gain access to the configuration options needed to enable the thread safety required by PHP＊s Runkit extension.

    --enable-so
The --enable-so configuration option was used to enable Apache＊s mod so module, which allows the server to load dynamic shared objects (DSOs) 

    --with-mpm=worker
The --with-mpm=worker configuration option was included to specify the multi-processing module (MPM) that Apache should use.

The default MPM is prefork. While this MPM is appropriate for powering sites that make use of non-thread-safe libraries, it was not chosen for this system because it is not compatible with PHP＊s Runkit Sandbox class.
It was therefore necessary to specify the use of the worker MPM, a hybrid multi-process multi-threaded server that is able to serve more requests using fewer system resources while still maintaining the thread-safety demanded by the aforementioned class.

----

##PHP Configuration

It was configured by manipulating configuration options during installation 每 once again, the focus was on enabling thread safety and creating a sandbox-friendly environment.

    --with-zlib
The zlib software library facilitates reverse engineering of this kind by allowing the system to decompress compressed data using the gzinflate() function.

    --enable-maintainer-zts and
    --enable-runkit

Thread safety was enabled by passing the `--enable-maintainer-zts` configuration option during the compilation process. 
The purpose of enabling thread safety was to provide an environment in which the Runkit extension could function - this extension was enabled using the last configuration option.

##The Decoder

The first of the major components developed for the system was the decoder, which is responsible for performing code normalisation and deobfuscation prior to execution in the sandbox environment.

The decoder is considered a static deobfuscator in that it manipulates the code without ever executing it.
The purpose of this component is to expose the underlying program logic and source code of an uploaded shell by removing any layers of obfuscation that may have been added by the shell＊s developer. 

1. Decode():

    The part of the Decoder class responsible for removing layers of obfuscation from PHP shells is the decode() function.
    It scans the code for the two functions most associated with obfuscation, namely eval() and preg replace(), both of which are capable of arbitrarily executing PHP code.
1. ProcessEvals():

    ![ProcessEvals](./img/Webshell/ProcessEvals.png)

    String processing techniques are used to detect the eval() constructs and any auxiliary string manipulation functions contained within them. The eval() is then removed from the script and its argument is stored as a string variable.
    Auxiliary functions are detected and stored in an array, which is then **reversed** and each function is applied to the argument. The result of this process is then re-inserted into the shell in place of the original construct.
    The processEvals() function was designed to be extensible.

1. ProcessPregReplace():

    ![processPregReplace](./img/Webshell/processPregReplace.png)

1. Information Gathering:

    The Decoder class contains three functions for extracting variables, URLs, and email addresses from PHP code
    Each of these functions uses simple pattern matching and regular expressions to locate the three code features.

    A list of these servers could potentially be stored and published as a URL blacklist that could then be blocked by ISPs or individual web hosts

##The Sandbox

The second major component developed for the system was the sandbox, which is responsible for executing the deobfuscated code produced by the decoder in a controlled environment.

it forms the dynamic part of the shell analysis process 每 information about the shell＊s functioning is extracted at runtime [42].  

The part of the sandbox responsible for identifying malicious functions and overriding them with functions that perform an identical task, but also record where in the code the call was made is the redefineFunctions() function. Finally, shell execution and call logging is performed to complete the process.

###Class Outline:

    the sandbox is mainly concerned with the configuration of the Runkit Sandbox, the redefinition of functions, and the monitoring of any malicious function calls. 

1. Runkit Sandbox Class:

    The sandbox＊s core component is the Runkit Sandbox class, an embeddable sub-interpreter capable of providing a safe environment in which to execute PHP code.  

1. Function Redefinition and Classification:

    The redefineFunctions() function is used to override potentially exploitable PHP functions with alternatives that perform identical tasks, but also log the function name, where it was called in the code, and type of vulnerability that the function represents. 

    1. the potentially exploitable function is copied using the Runkit extension＊s `runkit_function_copy()` function to preserve its functionality and prevent it from being overwritten completely
    1. The `runkit_function_redefine()` function is then used to override the original function, accepting the name of the original function, a list of new parameters, and a new function body as its arguments.

Functions with the potential for exploitation can be grouped into four main categories: command execution, code execution, information disclosure and filesystem functions.

#RESULTS

These ranged from the smaller unit tests designed to test specific scenarios to comprehensive tests that involved functional units from all parts of the system.

several active and fully-featured web shells were used as inputs to the system in order to assess its performance in a live production environment. 

##Decoder Tests

Each test was designed to clearly demonstrate a specific capability of the decoder. Finally, several tests were performed with the fully-functional web shells

##Single-level Eval() and Base64 decode()

To create the input script, a simple echo() statement (with ※Goodbye§ included as an argument) was encoded using PHP＊s base64 encode() function.

##Eval() with Auxiliary Functions

A slightly more complex eval() was tested to ensure that the system could cope with a combination of auxiliary string manipulation functions.

    eval(gzinflate(base64_decode(str_rot13(＊GIKKPhmVSslK +7 V2LJg+S3Lrv ...＊))));

The string shown in Listing 12 was subjected to the str rot(), base64 encode() and gzdeflate() functions before being placed in the eval() construct. 
The reverse of these functions (str rot13(), base64 decode() and gzinflate()) were then inserted ahead of the string.

##Single-level Preg_Replace()

The decoder was expected to detect the preg replace(), remove the ＊/e＊ modifier from the first argument to prevent evaluation, and then perform the preg replace(), leaving only the replacement string 

was able to deal with preg replace() constructs that contained explicit strings as arguments, but failed to deal with constructs that passed variables as arguments 

##Multi-level Eval() and Preg replace() with Auxiliary Functions

##Full Shell Test


As part of a final and more comprehensive set of tests, a fully-functional derivative of the popular c99 web shell was passed as input. The shell is wrapped within 13 eval(gzinflate(base64 decode())) constructs, the outermost of which is partially displayed in Listing 19.

    eval(gzinflate(base64_decode(＊FJ3HcqPsFkUVA ...＊)));

The decoder correctly produced the output shown in Listing 20. An analysis of the output found that *all eval() and preg replace() constructs had been correctly removed* from the input script.  

##Sandbox Tests

The tests for this component included determining whether functions could be correctly identified, copied and overridden, and whether example PHP scripts could be executed successfully within the sandbox.

##Function Copy

first step during function redefinition is the copying of the original function to a new function so that it can be overridden without losing its functionality.

The end result of this process should be the existence of two functions, one with the original function name that has been overridden to echo log information when it is called, and a new function that contains the logic of the original function. 

##Overriding and Classification of System Functions

Functions in the sandbox are overridden to report information about the name of the function and where it was called. The type of vulnerability that they represent should also be recorded.  

##Full Shell Test - connect-back.php

****

#SUMMARY

1. create a sandbox-based environment capable of safely executing and dissecting potentially malicious PHP code
1. a decoder component for performing normalisation and deobfuscation of input code prior to execution in the sandbox environment.

****

#FUTURE WORK

##System Structure

##Implementation Language

##Similarity Analysis and a Webshell Taxonomy

1. Code classification based on similarity to previously analysed samples
1. The construction of a taxonomy tracing the evolution of popular web shells such as c99, r57, b374k and barc0de [63] and their derivatives








































































































