


#分组密码(Block cypher)

分组密码（Block cypher，又称分块密码），是一种对称密钥密码。它的特点是将明文分成多个等长的组，并用相同的密码算法和密钥对每组分别进行加密和解密。其中典型的如DES和AES作为美国政府核定的标准加密算法，应用领域从电子邮件加密到银行交易转帐，非常广泛。

----

##工作模式

    密码学中，块密码的工作模式允许使用同一个块密码密钥对多于一块的数据进行加密，并保证其安全性。[1][2] 块密码自身只能加密长度等于密码块长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适填充方式将数据扩展到符合密码块大小的长度。一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全[1]。

    工作模式主要用来进行加密和认证。[1][3] 对加密模式的研究曾经包含数据的完整性保护，即在某些数据被修改后的情况下密码的误差传播特性。后来的研究则将完整性保护作为另一个完全不同的，与加密无关的密码学目标。部分现代的工作模式用有效的方法将加密和认证结合起来，称为认证加密模式。[2]

    虽然工作模式通常应用于对称加密[2]，它亦可以应用于公钥加密，例如在原理上对RSA进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用混合加密方案

----

###电子密码本（ECB）

 DES ECB（电子密本方式）其实非常简单，就是将数据按照8个字节一段进行DES加密或解密得到一段8个字节的密文或者明文，最后一段不足8个字节，按照需求补足8个字节进行计算，之后按照顺序将计算所得的数据连在一起即可，各段数据之间互不影响。

----

###密码块链接（CBC）

在CBC模式中，每个平文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有平文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。

加密步骤如下：

1. 首先将数据按照8个字节一组进行分组得到D1、D2......Dn（若数据不是8的整数倍，用指定的PADDING数据补位）
1. 第一组数据D1与初始化向量I异或后的结果进行DES加密得到第一组密文C1（初始化向量I为全零）
1. 第二组数据D2与第一组的加密结果C1异或以后的结果进行DES加密，得到第二组密文C2
1. 之后的数据以此类推，得到Cn
1. 按顺序连为C1C2C3......Cn即为加密结果。

----

解密是加密的逆过程，步骤如下：

1. 首先将数据按照8个字节一组进行分组得到C1C2C3......Cn
1. 将第一组数据进行解密后与初始化向量I进行异或得到第一组明文D1（注意：一定是先解密再异或）
1. 将第二组数据C2进行解密后与第一组密文数据进行异或得到第二组数据D2
1. 之后依此类推，得到Dn
1. 按顺序连为D1D2D3......Dn即为解密结果。

----

填充密码块链接（PCBC）
密文反馈（CFB）
输出反馈（OFB）
计数器模式（CTR）

----

##初始化向量（IV）

    初始化向量（IV，Initialization Vector）是许多工作模式中用于随机化加密的一块数据，因此可以由相同的明文，相同的密钥产生不同的密文，而无需重新产生密钥，避免了通常相当复杂的这一过程。

    初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露平文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。另外，在CBC模式中，IV在加密时必须是无法预测的；特别的，在许多实现中使用的产生IV的方法，例如SSL2.0使用的，即采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的[12]。

----

##填充

    块密码只能对确定长度的数据块进行处理，而消息的长度通常是可变的。因此部分模式（即ECB和CBC）需要最后一块在加密前进行填充。有数种填充方法，其中最简单的一种是在平文的最后填充空字符以使其长度为块长度的整数倍，但必须保证可以恢复平文的原始长度；例如，若平文是C语言风格的字符串，则只有串尾会有空字符。稍微复杂一点的方法则是原始的DES使用的方法，即在数据后添加一个1位，再添加足够的0位直到满足块长度的要求；若消息长度刚好符合块长度，则添加一个填充块。最复杂的则是针对CBC的方法，例如密文窃取，残块终结等，不会产生额外的密文，但会增加一些复杂度。布鲁斯・施奈尔和尼尔斯・弗格森提出了两种简单的可能性：添加一个值为128的字节（十六进制的80），再以0字节填满最后一个块；或向最后一个块填充n个值均为n的字节[13]。

    CFB，OFB和CTR模式不需要对长度不为密码块大小整数倍的消息进行特别的处理。因为这些模式是通过对块密码的输出与平文进行异或工作的。最后一个平文块（可能是不完整的）与密钥流块的前几个字节异或后，产生了与该平文块大小相同的密文块。流密码的这个特性使得它们可以应用在需要密文和平文数据长度严格相等的场合，也可以应用在以流形式传输数据而不便于进行填充的场合。

----

##分块大小

现代加密算法中，对称密钥算法通常被分为stream ciphers和block ciphers。分块密码处理固定长度的字符串位数(bit)。这个比特字符串的长度必须和分块大小一样长。输入（明文）和输出（密文）都是同样长度的。输出不能比输入短――这是遵循Pigeonhole principle（鸽巢原理，又名狄利克雷抽屉原理、鸽笼原理）和密码必须是可逆的事实――然而，输出比输入更长又是不可取的。

> 鸽巢原理:
> 其中一种简单的表述法为：
> 若有n个笼子和n+1只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少2只鸽子。
> 另一种为：
> 若有n个笼子和kn+1只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少k+1只鸽子。
> 拉姆齐定理是此原理的推广。

****

##Blowfish

布鲁斯・施奈尔 （Bruce Schneier，1963年1月15日－）是一位美国的密码学学者、信息安全专家与作家。他撰写了数本信息安全与密码学相关的书籍，并且创办了BT公司并担任其首席技术官(CTO)。

----

BlowFish 使用了两个box,除了著名的S-box，还有一个p-box

1. pbox有18个unsigned long元素
1. sbox有4×256个unsigned long元素

BlowFish算法中，有一个核心加密函数，该函数输入64位信息，运算后， 以64位密文的形式输出。 用BlowFish算法加密信息，需要两个过程：

1. 密钥预处理
2. 信息加密

----

###密钥预处理

BlowFish算法的源密钥――pbox和sbox是固定的。此pbox和sbox的值来自PI的十六进制数字值，使用这些数的原因是这些数看不出有什么明显的规律。(PI)

1. 用原sbox: ORIG_S 填充 sbox
1. 然后，每次取key与data进行运算，运算后的结果送给pbox

    进行N+2次运算（N=16),
    令 32位无符号data为0,由于Key是unsigned char类型的，每次对data左移8位(一个字节)之后与相应的key相或（即相加），当key长度小于4时，循环使用Key。

1. 接下来，用bf_encypt加密一个全0的64位信息（分为datal和datar,各32位）,用输出的结果datal和datar分别替换pbox[0]和pbox[1]
1. 然后，继续加密datal和datar,用输出结果替换pbox[2]和pbox[3]
1. 这样循环18次，把pbox全部替换完成。
1. 接下来使用上面运算过的datal与datar对sbox进行替换了。

----

###信息加密

进行16轮运算：
    令i=0,1,2,3,…,N-1
    Xl = Xl ^ ctx->P[i];
    Xr = F(ctx, Xl) ^ Xr;






****

##DES

  DES算法为密码体制中的对称密码体制，又被称为美国数据加密标准，是1972年美国IBM公司研制的对称密码体制加密算法。 明文按64位进行分组，密钥长64位，密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1）分组后的明文组和56位的密钥按位替代或交换的方法形成密文组的加密方法。

----

需掌握以下几点即可：

1. 模2加运算

    这个是比较好理解的，就是两个数相加然后除2取余。

2. 理解其中的置换

    一开始的时候就会对明文进行置换，通过初始置换IP：

----

###置换

标准表中PC-1的第一个58就是你明文中的第58个元素，你要放到1的位置，然后把明文中第50个元素放到2的位置，以此类推

子密钥生成分为三步走：

1. 第一步，先把密钥中的奇偶校验为去掉，然后根据选择置换PC-1讲剩下的密钥分成两块C0和D0；
1. 第二步，将C0和D0进行循环左移变换，变换后生成C1和D1，然后C1和D1合并，通过选择置换PC-2生成子密钥K1；
1. 第三步，C1和D1再次经过循环左移变换，生成C2和D2，C2和D2合并，通过选择置换PC-2生成子密钥K2；
1. 第四步，以此类推，需要注意其中循环左移的位数，一共是循环左移十六次，其中LS1（第一次），LS2（第二次），LS9，LS16是循环左移一位，其他的都是左移两位。

![标准表1](./img/Cryptography/DES/标准表_1.jpg)

----

###加密

加密函数的加密过程也可以通过三步走：

1. 第一步，将R0通过位选择函数E置换，其实这是一个扩充的置换，因为R0本身是32位的（这点先记住就行了，后一篇文章会说），而生成的子密钥是48位的，因此需要扩充一下，方能按位运算。
1. 第二步，将扩充完的R0和子密钥K1进行模2加运算，得到48位的一个串，把这个串从左到右分为8组，每组6个字符。这里设8组分别为B1，B2，B3，B4，B5，B6，B7，B8。其中Bj=b1b2b3b4b5b6。
1. 第三步，通过S盒来收缩，把每组中的b1b6放一块，换算为十进制，b2b3b4b5放一块，也换算为十进制。b1b6代表S盒中的行标，b2b3b4b5代表列标。比如说B1=011111，那么b1b6就等于十进制的1，b2b3b4b5等于十进制的15，也就是对应表中的S1块中的第1行（注意不是0行），15列，也就是8，然后把8变为二进制1000。这就完成了S盒收缩变换，然后通过S盒输出的就是32位的一个串。
1. 第四步，把32位的串经过置换函数P的置换得到的结果就是这个核心函数的产物了。


----


****

##3DES
3DES算法顾名思义就是3次DES算法，其算法原理如下：

设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密表，这样，

    3DES加密过程为：C=Ek3(Dk2(Ek1(P)))
    3DES解密过程为：P=Dk1((EK2(Dk3(C)))

> 这里可以K1=K3，但不能K1=K2=K3（如果相等的话就成了DES算法了）

----

3DES with 2 diffrent keys（K1=K3），可以是3DES-CBC，也可以是3DES-ECB，3DES-CBC整个算法的流程和DES-CBC一样，但是在原来的加密或者解密处增加了异或运算的步骤，使用的密钥是16字节长度的密钥，将密钥分成左8字节和右8字节的两部分，即k1=左8字节，k2=右8字节，然后进行加密运算和解密运算。

3DES with 3 different keys，和3DES-CBC的流程完全一样，只是使用的密钥是24字节的，但在每个加密解密加密时候用的密钥不一样，将密钥分为3段8字节的密钥分别为密钥1、密钥2、密钥3，在3DES加密时对加密解密加密依次使用密钥1、密钥2、密钥3，在3DES解密时对解密加密解密依次使用密钥3、密钥2、密钥1。



