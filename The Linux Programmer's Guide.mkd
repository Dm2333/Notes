
#The Linux Programmer's Guide

http://www.tldp.org/LDP/lpg/lpg.html

##System V IPC

###Fundamental Concepts

With System V, AT&T introduced three new forms of IPC facilities (message queues, semaphores, and shared memory). While the POSIX committee has not yet completed its standardization of these facilities, most implementations do support these. In addition, Berkeley (BSD) uses sockets as its primary form of IPC, rather than the System V elements. Linux has the ability to use both forms of IPC (BSD and System V), although we will not discuss sockets until a later chapter. 

The Linux implementation of System V IPC was authored by Krishna Balasubramanian, at balasub@cis.ohio-state.edu. 

----

IPC Identifiers

Each IPC object has a unique IPC identifier associated with it. When we say ``IPC object'', we are speaking of a single message queue, semaphore set, or shared memory segment. This identifier is used within the kernel to uniquely identify an IPC object.

For example, to access a particular shared memory segment, the only item you need is the unique ID value which has been assigned to that segment. 

*The uniqueness of an identifier is relevant to the type of object in question*. To illustrate this, assume a numeric identifier of ``12345''. While there can never be two message queues with this same identifier, there exists the distinct possibility of a message queue and, say, a shared memory segment, which have the same numeric identifier. 

----

IPC Keys

To obtain a unique ID, a key must be used. The key must mutally aggreed upon by both client and server processes. This represents the first step in constructing a client/server framework for an application.

The key can be the same value every time, by hardcoding a key value into an application. This has the disadvantage of the key possibly being in use already. Often, the ftok() function is used to generate key values for both the client and the server. 

    LIBRARY FUNCTION: ftok();
    
    PROTOTYPE: key_t ftok ( char *pathname, char proj );
      RETURNS: new IPC key value if successful
               -1 if unsuccessful, errno set to return of stat() call

The returned key value from `ftok()` is generated by combining the inode number and minor device number from the file in argument one, with the one character project indentifier in the second argument. This doesn't guarantee uniqueness, but an application can check for collisions and retry the key generation. 

    key_t   mykey;
    mykey = ftok("/tmp/myapp", 'a');

In the above snippet, the directory /tmp/myapp is combined with the one letter identifier of 'a'. Another common example is to use the current directory: 

    key_t   mykey;
    mykey = ftok(".", 'a');

The key value, however it is obtained, is used in subsequent IPC system calls to create or gain access to IPC objects. 

---

The `ipcs` Command

The `ipcs` command can be used to obtain the status of all System V IPC objects.

By default, all three categories of objects are shown. Consider the following sample output of `ipcs`: 

    ------ Shared Memory Segments --------
    shmid     owner     perms     bytes     nattch    status      
    
    ------ Semaphore Arrays --------
    semid     owner     perms     nsems     status      
    
    ------ Message Queues --------
    msqid     owner     perms     used-bytes  messages    
    0         root      660       5           1

Here we see a single message queue which has an identifier of ``0''. It is owned by the user root, and has octal permissions of 660, or -rw-rw--. There is one message in the queue, and that message has a total size of 5 bytes. 

----

The `ipcrm` Command

The ipcrm command can be used to remove an IPC object from the kernel. While IPC objects can be removed via system calls in user code (we'll see how in a moment), the need often arises, especially under development environments, to remove IPC objects manually. Its usage is simple: 

    ipcrm <msg | sem | shm>  <IPC ID>

Simply specify whether the object to be deleted is a message queue (msg), a semaphore set (sem), or a shared memory segment (shm). The IPC ID can be obtained by the ipcs command. You have to specify the type of object, since identifiers are unique among the same type

----

###Message Queues

Basic Concepts

Message queues can be best described as an internal linked list within the kernel's addressing space. Messages can be sent to the queue in order and retrieved from the queue in several different ways. Each message queue (of course) is uniquely identified by an IPC identifier. 

----

Internal and User Data Structures

The key to fully understanding such complex topics as System V IPC is to become intimately familiar with the various internal data structures that reside within the confines of the kernel itself. Direct access to some of these structures is necessary for even the most primitive operations, while others reside at a much lower level. 

----

Message buffer

This particular data structure can be thought of as a template for message data. While it is up to the programmer to define structures of this type, it is imperative that you understand that there is actually a structure of type msgbuf. It is declared in linux/msg.h as follows: 

    /* message buffer for msgsnd and msgrcv calls */
    struct msgbuf {
        long mtype;         /* type of message */
        char mtext[1];      /* message text */
    };

> `mtype`, the message type, represented in a positive number

The ability to assign a given message a type, essentially gives you the capability to multiplex messages on a single queue. For instance, client processes could be assigned a magic number, which could be used as the message type for messages sent from a server process. The server itself could use some other number, which clients could use to send messages to it. In another scenario, an application could mark error messages as having a message type of 1, request messages could be type 2, etc. The possibilities are endless. 

On another note, do not be misled by the almost too-descriptive name assigned to the message data element (mtext). This field is not restricted to holding only arrays of characters, but any data, in any form. The field itself is actually completely arbitrary, since this structure gets redefined by the application programmer. Consider this redefinition: 

    struct my_msgbuf {
            long    mtype;          /* Message type */
            long    request_id;     /* Request identifier */
            struct  client info;    /* Client information structure */
    };

Here we see the message type, as before, but the remainder of the structure has been replaced by two other elements, one of which is another structure! This is the beauty of message queues. The kernel makes no translations of data whatsoever. Any information can be sent. 

There does exist an internal limit, however, of the maximum size of a given message. In Linux, this is defined in linux/msg.h as follows: 

    #define MSGMAX  4056   /* <= 4056 */   /* max size of message (bytes) */

Messages can be no larger than 4,056 bytes in total size, including the mtype member, which is 4 bytes in length (long). 

----

Kernel `msg` structure

The kernel stores each message in the queue within the framework of the `msg` structure. It is defined for us in linux/msg.h as follows: 

    /* one msg structure for each message */
    struct msg {
        struct msg *msg_next;   /* next message on queue */
        long  msg_type;          
        char *msg_spot;         /* message text address */
        short msg_ts;           /* message text size */
    };

- msg_next

    This is a pointer to the next message in the queue. They are stored as a singly linked list within kernel addressing space.
- msg_type

    This is the message type, as assigned in the user structure msgbuf.
- msg_spot

    A pointer to the beginning of the message body.
- msg_ts

    The length of the message text, or body. 

----

Kernel `msqid_ds` structure

Each of the three types of IPC objects has an internal data structure which is maintained by the kernel. For message queues, this is the `msqid_ds` structure. The kernel creates, stores, and maintains an instance of this structure for every message queue created on the system. It is defined in linux/msg.h as follows: 

    /* one msqid structure for each queue on the system */
    struct msqid_ds {
        struct ipc_perm msg_perm;
        struct msg *msg_first;  /* first message on queue */
        struct msg *msg_last;   /* last message in queue */
        time_t msg_stime;       /* last msgsnd time */
        time_t msg_rtime;       /* last msgrcv time */
        time_t msg_ctime;       /* last change time */
        struct wait_queue *wwait;
        struct wait_queue *rwait;
        ushort msg_cbytes;    
        ushort msg_qnum;     
        ushort msg_qbytes;      /* max number of bytes on queue */
        ushort msg_lspid;       /* pid of last msgsnd */
        ushort msg_lrpid;       /* last receive pid */
    };

- msg_perm

    An instance of the ipc_perm structure, which is defined for us in linux/ipc.h. This holds the permission information for the message queue, including the access permissions, and information about the creator of the queue (uid, etc).
- msg_first

    Link to the first message in the queue (the head of the list).
- msg_last

    Link to the last message in the queue (the tail of the list).
- msg_stime

    Timestamp (time_t) of the last message that was sent to the queue.
- msg_rtime

    Timestamp of the last message retrieved from the queue.
- msg_ctime

    Timestamp of the last ``change'' made to the queue (more on this later).
- wwait

    and
- rwait

    Pointers into the kernel's wait queue. They are used when an operation on a message queue deems the process go into a sleep state (i.e. queue is full and the process is waiting for an opening).
- msg_cbytes

    Total number of bytes residing on the queue (sum of the sizes of all messages).
- msg_qnum

    Number of messages currently in the queue.
- msg_qbytes

    Maximum number of bytes on the queue.
- msg_lspid

    The PID of the process who sent the last message.
- msg_lrpid

    The PID of the process who retrieved the last message. 

----

Kernel `ipc_perm` structure

The kernel stores permission information for IPC objects in a structure of type `ipc_perm`. For example, in the internal structure for a message queue described above, the msg_perm member is of this type. It is declared for us in linux/ipc.h as follows: 

    struct ipc_perm
    {
      key_t  key;
      ushort uid;   /* owner euid and egid */
      ushort gid;
      ushort cuid;  /* creator euid and egid */
      ushort cgid;
      ushort mode;  /* access modes see mode flags below */
      ushort seq;   /* slot usage sequence number */
    };

All of the above are fairly self-explanatory. Stored along with the IPC key of the object is information about both the creator and owner of the object (they may be different). The octal access modes are also stored here, as an unsigned short. Finally, the slot usage sequence number is stored at the end. Each time an IPC object is closed via a system call (destroyed), this value gets incremented by the maximum number of IPC objects that can reside in a system. Will you have to concern yourself with this value? No. 



