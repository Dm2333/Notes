

![UMA_Sequence_Diagram.png](UMA_Sequence_Diagram.png)

#User-Managed Access (UMA) 2.0 Grant for Oauth 2.0 Authorization

#Abstract

This specification defines a means for a client, representing a requesting party, to use a permission ticket to request an OAuth 2.0 access token to gain access to a protected resource asynchronously from the time a resource owner authorizes access.


#Introduction

This specification defines a means for a client, representing a requesting party, to use a permission ticket to request an OAuth 2.0 access token to gain access to a protected resource asynchronously from the time a resource owner authorizes access.

1. This specification defines a means for a client, representing a requesting party, to use a permission ticket to request an OAuth 2.0 access token to gain access to a protected resource asynchronously from the time a resource owner authorizes access.
2. The authorization server and resource server interact with the client and requesting party in a way that is **asynchronous** with respect to resource owner interactions. This lets a resource owner configure an authorization server with authorization grant rules (policy conditions) at will, rather than authorizing access token issuance synchronously just after authenticating.

##Roles

- resource owner

    The authorization server and resource server interact with the client and requesting party in a way that is asynchronous with respect to resource owner interactions. This lets a resource owner configure an authorization server with authorization grant rules (policy conditions) at will, rather than authorizing access token issuance synchronously just after authenticating.
    
- Requesting party

    A natural or legal person that uses a client to seek access to a protected resource. The requesting party may or may not be the same party as the resource owner. 
   
- client

    An application that is capable of making requests for protected resources with the resource owner's authorization and on the requesting party's behalf. 
    
- Resource Server

    A server that hosts resources on a resource owner's behalf and is capable of accepting and responding to requests for protected resources.
    
- authorization server

    A server that protects, on a resource owner's behalf, resources hosted at a resource server.
    
----

##Abstract Flow

requesting                             authorization resource resource
  party        client                      server     server    owner
    |            |                           |          |         |
    |            |                           |Set policy|         |
    |            |                           |conditions (anytime)|
    |            |                           |<- - - - - - - - - -|
    |            |Resource request (no access token)    |         |
    |            |------------------------------------->|         |
    |            |401 response with initial permission  |         |
    |            |ticket, authz server location         |         |
    |            |<-------------------------------------|         |
    |            |Access token (RPT) request |          |         |
    |            |with permission ticket,    |          |         |
    |            |claim token (push claims)  |          |         |
    |            |-------------------------->|          |         |
    |            |                      +----|Authz     |         |
    |            |                      +--->|assessment|         |
    |            |403 response with new      |          |         |
    |            |permission ticket,         |          |         |
    |            |need_info error,           |          |         |
    |            |redirect_user hint         |          |         |
    |            |<--------------------------|          |         |
    |Redirect    |                           |          |         |
    |user with   |                           |          |         |
    |permission  |                           |          |         |
    |ticket      |                           |          |         |
    |<-----------|                           |          |         |
    |Follow redirect to authz server         |          |         |
    |--------------------------------------->|          |         |
    |Interactive claims gathering            |          |         |
    |<- - - - - - - - - - - - - - - - - - - >|          |         |
    |Redirect back with new permission       |          |         |
    |ticket                                  |          |         |
    |<---------------------------------------|          |         |
    |Follow      |                           |          |         |
    |redirect    |                           |          |         |
    |to client   |                           |          |         |
    |----------->|                           |          |         |
    |            |RPT request with permission|          |         |
    |            |ticket                     |          |         |
    |            |-------------------------->|          |         |
    |            |                      +----|Authz     |         |
    |            |                      +--->|assessment|         |
    |            |Response with RPT and PCT  |          |         |
    |            |<--------------------------|          |         |
    |            |Resource request with RPT  |          |         |
    |            |------------------------------------->|         |
    |            |Protected resource         |          |         |
    |            |<-------------------------------------|         |

----

- requesting party token (RPT)

    An OAuth access token associated with the UMA grant. An RPT is unique to a requesting party, client, authorization server, resource server, and resource owner.
    
- permission

    Authorized access to a particular resource with some number of scopes bound to that resource. A permission ticket represents some number of requested permissions. An RPT represents some number of granted permissions. Permissions are part of the authorization server's process and are opaque to the client.
    
- permission ticket

    A correlation handle *representing requested permissions* that is created and maintained by the authorization server, initially passed to the client by the resource server, and presented by the client at the token endpoint and during requesting party redirects.
    
- authorization process

    The process through which the authorization server determines whether it should issue an RPT to the client on the requesting party's behalf, based on a variety of inputs. A key component of the process is **authorization assessment**. (See Section 1.3.1.)
    
- claim

    A statement of the value or values of one or more attributes of an entity. The authorization server typically needs to *collect and assess one or more claims of the requesting party or client against policy conditions as part of protecting a resource*. The two methods available for UMA claims collection are **claims pushing** and **interactive claims gathering**. Note: Claims collection might involve authentication for unique user identification, but depending on policy conditions might additionally or instead involve the collection of non-uniquely identifying attributes, authorization for some action (for example, see Section 3.3.3), or other statements of agreement.

- claim token

    A package of claims provided directly by the client to the authorization server through **claims pushing**.

- Persisted claim token (PCT)

    A correlation handle issued by an authorization server that represents a set of claims collected during one authorization process, available for a client to use in attempting to optimize a future authorization process.
    
----

###Authorization process

- Claims collection. 

    **Claims pushing** by a client is defined in Section 3.3.1, and **interactive claims gathering** with an end-user requesting party is defined in Section 3.3.2.
    
- Authorization assessment (as defined in Section 3.3.4). 

    Authorization assessment involves the authorization server assembling and evaluating policy conditions, scopes, claims, and any other relevant information sourced outside of UMA claims collection flows, in order to mitigate access authorization risk.
    
- Authorization results determination (as defined in Section 3.3.4). 

    The authorization server either returns a success code (as defined in Section 3.3.5), an RPT, and an optional PCT, or an error code (as defined in Section 3.3.6). If the error code is need_info or request_submitted, the authorization server provides a permission ticket, giving the client an opportunity to continue within the same authorization process (including engaging in further claims collection).
    
Different choices of claims collection methods, other inputs to authorization assessment, and error codes might be best suited for different deployment ecosystems. For example, where no pre-established relationship is expected between the resource owner's authorization server and the requesting party, initial requesting party redirection might be a useful pattern, at which point *the authorization server might either authenticate the requesting party locally or serve as a relying party for a remote identity provider*. Where a common authorization server functions as an identity provider for all resource owners and requesting parties, having the client push claim tokens sourced from that central server itself with a pre-negotiated format and contents might be a useful pattern.

----

##Authorization Server Metadata

The authorization server supplies metadata in a discovery document to declare its endpoints. The client uses its discovery document to discover these endpoint for use in the flow defined in Section 3.

The authorization server MUST make a discovery document available. The structure of the discovery document MUST conform to that defined in [OAuthMeta]. The discovery document MUST be available at an endpoint formed by concatenating the string /.well-known/uma2-configuration to the issuer metadata value defined in [OAuthMeta], using the well-known URI syntax and semantics defined in [RFC5785]. In addition to the metadata defined in [OAuthMeta], this specification defines the following metadata for inclusion in the discovery document:

- claims_interaction_endpoint

    OPTIONAL. *A static endpoint URI at which the authorization server declares that it interacts with end-user requesting parties to gather claims*. If the authorization server also provides a claims interaction endpoint URI as part of its redirect_user hint in a need_info response to a client on authorization failure (see Section 3.3.6), that value overrides this metadata value. Providing the static endpoint URI is useful for enabling **interactive claims gathering** prior to any pushed-claims flows taking place, for example, for gathering authorization for subsequent claim pushing (see Section 3.3.2).
    
- uma_profile_supported

    OPTIONAL. UMA profiles and extensions supported by this authorization server. The value is an array of string values, where each string value is a URI identifying an UMA profile or extension. As discussed in Section 4, an authorization server supporting a profile or extension related to UMA SHOULD supply the specification's identifying URI (if any) here.
    
If the authorization server supports dynamic client registration, it MUST allow client applications to register claims_redirect_uri metadata, as defined in Section 3.3.2, using the following metadata field:

- claims_redirect_uris

    OPTIONAL. Array of one or more claims redirection URIs.
    
----

#Flow Detail#

##Client Requests Resource Without Providing an Access Token

The client requests a protected resource without providing any access token.

Note: This process does not assume that any relevant policy conditions have already been defined at the authorization server.

For an example of how the resource server can put resources under the protection of an authorization server, see [UMAFedAuthz].

Example of a client request at a protected resource without providing an access token:

    GET /users/alice/album/photo.jpg HTTP/1.1
    Host: photoz.example.com
    ...
    
----

##Resource Server Responds to Client's Tokenless Access Attempt

The resource server responds to the client's tokenless resource request.

*The resource server MUST obtain a permission ticket from the authorization server to provide in its response*, but the means of doing so is outside the scope of this specification. For an example of how the resource server can obtain the permission ticket, see [UMAFedAuthz].

The process of choosing what permissions to request from the authorization server may require interpretation and mapping of the client's resource request. The resource server SHOULD request a set of permissions with scopes that is reasonable for the client's resource request.

Note: In order for the resource server to know which authorization server to approach for the permission ticket and on which resource owner's behalf, *it needs to derive the necessary information using cues provided by the structure of the API where the resource request was made, rather than by an access token*. Commonly, this information can be passed through the URI, headers, or body of the client's request. Alternatively, the entire interface could be dedicated to the use of a single resource owner and protected by a single authorization server.

See Section 5.5 for permission ticket security considerations.

----

###Resource Server Responds to Client on Permission Request Success

If the resource server is able to provide a permission ticket from the authorization server, it responds to the client by providing a WWW-Authenticate header with the authentication scheme UMA, with the issuer URI from the authorization server's discovery document in an as_uri parameter and the permission ticket in a ticket parameter.

For example:

    HTTP/1.1 401 Unauthorized
    WWW-Authenticate: UMA realm="example",
      as_uri="https://as.example.com",
      ticket="016f84e8-f9b9-11e0-bd6f-0021cc6004de"
    ...
    
----

###Resource Server Response to Client on Permission Request Failure

If the resource server is unable to provide a permission ticket from the authorization server, then it includes a header of the following form in its response to the client: Warning: 199 - "UMA Authorization Server Unreachable".

For example:
    
    HTTP/1.1 403 Forbidden
    Warning: 199 - "UMA Authorization Server Unreachable"
    ...

Without an authorization server location and permission ticket, the client is unable to continue.

----

##Client Seeks RPT on Requesting Party's Behalf

The client seeks issuance of an RPT.

This process assumes that:

- The client has obtained a permission ticket and an authorization server location from the resource server.
- The client has retrieved the authorization server's discovery document as needed.
- The client has obtained a client identifier or a full set of client credentials as appropriate, either statically or dynamically (for example, through [RFC7591] or [OIDCDynClientReg]). This grant works with clients of both confidential and public types. (Where does this come from)

Initiation of this process has two options. 
1. One option is for the client to request an RPT from the token endpoint immediately, as defined in Section 3.3.1. Claim pushing is available at this endpoint. (Where is the token endpoint?)
2. The other option, if the authorization server’s discovery document statically provided a claims interaction endpoint, is for the client to redirect the requesting party immediately to that endpoint for **interactive claims gathering**, as defined in Section 3.3.2.

----

###Client Request to Authorization Server for RPT

The client makes a request to the token endpoint by sending the following parameters:

- grant_type
  
    REQUIRED. MUST be the value urn:ietf:params:oauth:grant-type:uma-ticket.
    
- ticket

    REQUIRED. The most recent permission ticket received by the client as part of this authorization process.
    
- claim_token

    OPTIONAL. If this parameter is used, it MUST appear together with the claim_token_format parameter. *A string containing directly pushed claim information in the indicated format*. It MUST be base64url encoded unless specified otherwise by the claim token format. The client MAY provide this information on both first and subsequent requests to this endpoint. The client and authorization server together might need to establish proper audience restrictions for the claim token prior to claims pushing.

- claim_token_format

    OPTIONAL. If this parameter is used, it MUST appear together with the claim_token parameter. A string specifying the format of the claim token in which the client is directly pushing claims to the authorization server. The string MAY be a URI. Examples of potential types of claim token formats are [OIDCCore] ID Tokens and SAML assertions.
    
- pct

    OPTIONAL. *If the authorization server previously returned a PCT along with an RPT, the client MAY include the PCT in order to optimize the process of seeking a new RPT*. Given that some claims represented by a PCT are likely to contain identity information about a requesting party, a client supplying a PCT in its RPT request MUST make a best effort to ensure that the requesting party using the client now is the **same** as the requesting party that was associated with the PCT when it was issued. The client MAY use the PCT for the same requesting party when seeking an RPT for a resource different from the one sought when the PCT was issued, or a protected resource at a different resource server entirely. See Section 5.2 for additional PCT security considerations. See Section 3.3.5 for the form of the authorization server's response with a PCT.
    
- rpt

    OPTIONAL. Supplying an existing RPT (which MAY be expired) *gives the authorization server the option of upgrading that RPT instead of issuing a new one* (see Section 3.3.5.1 for more about this option).
    
- scope

    OPTIONAL. A string of space-separated values representing requested scopes. *For the authorization server to consider any requested scope in its assessment, the client MUST have been pre-registered for the same scope with the authorization server*. The client should consult the resource server's API documentation for details about which scopes it can expect the resource server's initial returned permission ticket to represent as part of the authorization assessment (see Section 3.3.4).
    
----

Example of a request message with no optional parameters (line breaks are shown only for display convenience):

    POST /token HTTP/1.1
    Host: as.example.com
    Authorization: Basic jwfLG53^sad$#f
    ...
    grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Auma-ticket
    &ticket=016f84e8-f9b9-11e0-bd6f-0021cc6004de
    
----

Example of a request message that includes an existing RPT for upgrading, a scope being sought that was previously registered with the authorization server, and a PCT and a claim token for consideration in the authorization process:

    POST /token HTTP/1.1
    Host: as.example.com
    Authorization: Basic jwfLG53^sad$#f
    ...
    grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Auma-ticket
    &ticket=016f84e8-f9b9-11e0-bd6f-0021cc6004de
    &claim_token=eyj0...
    &claim_token_format=http%3A%2F%2Fopenid.net%2Fspecs%2Fopenid-connect-core-1_0.html%23IDToken
    &pct=c2F2ZWRjb25zZW50
    &rpt=sbjsbhs(/SSJHBSUSSJHVhjsgvhsgvshgsv
    &scope=read

This specification provides a mean to define profiles of claim token formats for use with UMA. The authorization server SHOULD document the profiles it supports in its discovery document.

----

###Client Redict of Requesting Party to Authorization Server for Interactive Claims-Gathering

The client redirects an end-user requesting party to the authorization server's *claims interaction endpoint* for one or more *interactive claims-gathering processes* as the authorization server requires. These can include direct interactions, such as account registration and authentication local to the authorization server as an identity provider, filling out a questionnaire, *or asking the user to authorize persistent storage of any collected claims to optimize future authorization processes; this last example could potentially be associated with the authorization server's subsequent issuance of a PCT*. Interactions could also involve further redirection, for example, for federated (such as social) authentication at a remote identity provider, and other federated claims gathering.

The client might have initiated redirection immediately on receiving an initial permission ticket from the resource server, or, for example, in response to receiving a `redirect_user` hint in a `need_info` error (see Section 3.3.6).

In order for the client to redirect the requesting party immediately on receiving the initial permission ticket from the resource server, this process assumes that *the authorization server has statically declared its claims interaction endpoint in its discovery document*.

The client constructs the request URI by adding the following parameters to the query component of the claims interaction endpoint URI using the application/x-www-form-urlencoded format:

- client_id

    REQUIRED. The client's identifier issued by the authorization server.
    
- ticket

    REQUIRED. The most recent permission ticket received by the client as part of this authorization process.

- claims_redirect_uri

    REQUIRED if the client has pre-registered multiple claims redirection URIs or has pre-registered no claims redirection URI; OPTIONAL only if the client has pre-registered a single claims redirection URI. The URI to which the client wishes the authorization server to direct the requesting party's user agent after completing its interaction. The URI MUST be absolute, MAY contain an application/x-www-form-urlencoded-formatted query parameter component that MUST be retained when adding additional parameters, and MUST NOT contain a fragment component. The client SHOULD pre-register its claims_redirect_uri with the authorization server, and the authorization server SHOULD require all clients, and MUST require public clients, to pre-register their claims redirection endpoints (see Section 2). Claims redirection URIs are different from the redirection URIs defined in [RFC6749] in that they are intended for the exclusive use of requesting parties and not resource owners. Therefore, authorization servers MUST NOT redirect requesting parties to pre-registered redirection URIs defined in [RFC6749] unless such URIs are also pre-registered specifically as claims redirection URIs. If the URI is pre-registered, this URI MUST exactly match one of the pre-registered claims redirection URIs, with the matching performed as described in Section 6.2.1 of [RFC3986] (Simple String Comparison).

-   state

    RECOMMENDED. An opaque value used by the client to *maintain state between the request and callback*. The authorization server includes this value when *redirecting the user agent back to the client*. The use of this parameter is for preventing cross-site request forgery (see Section 5.1 for further security information).
    
----
    
Example of a request issued by a client application (line breaks are shown only for display convenience):

    GET /rqp_claims?client_id=some_client_id
    &ticket=016f84e8-f9b9-11e0-bd6f-0021cc6004de
    &claims_redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fredirect_claims
    &state=abc HTTP/1.1
    Host: as.example.com

----

###Authorization Server Redirect of Requesting Party Back to Client After Interactive Claims-Gathering

At the conclusion of a successful interaction with the requesting party, the authorization server returns the requesting party to the client, adding the following parameters to the query component of the claims redirection URI using the application/x-www-form-urlencoded format:

1. ticket
   
    REQUIRED. A **permission ticket** that allows the client to make further requests to the authorization server during this authorization process. The value MUST NOT be the same as the one the client used to make its request.
    
1. state
   
    OPTIONAL. The same state value that the client provided in the request. It MUST be present if and only if the client provided it (see Section 5.1 for further security information).
    
----

> Note: Interactive claims-gathering processes are outside the scope of this specification. *The purpose of the interaction is for the authorization server to gather information for its own authorization assessment purposes*. This redirection does not involve sending any of the information back to the client.

The authorization server MAY use interactive claims-gathering to request authorization from the requesting party for persisting claims across authorization processes. Such persisted claims will be represented by a PCT issued to the client in a subsequent step.

The client MUST ignore unrecognized response parameters. If the request fails due to a missing, invalid, or mismatching claims redirection URI, or if the client identifier is missing or invalid, the authorization server SHOULD inform the requesting party of the error and MUST NOT automatically redirect the user agent to the invalid redirection URI.

If the request fails for reasons other than a missing or invalid claims redirection URI, the authorization server informs the client by adding an error parameter to the query component of the claims redirection URI as defined in Section 4.1.2.1 of [RFC6749].

----

Example of a response issued by an authorization server (line breaks are shown only for display convenience):

    HTTP/1.1 302 Found
    Location: https://client.example.com/redirect_claims?
    ticket=cHJpdmFjeSBpcyBjb250ZXh0LCBjb250cm9s&state=abc
    
----

###Authorization Assessment and Results Determination

When the requesting server has received a request for an RPT from a client as defined in Section 3.3.1, it assesses whether the client is authorized to receive the requested RPT and determines the results.

The authorization server MUST apply the following conceptual authorization assessment calculation in determining authorization results. Note: As this calculation is internal to authorization server operations, its particulars are outside the scope of this specification. 

1. Assemble a set called **RegisteredScopes** containing the scopes for which the client is pre-registered (either dynamically or through some static process) at the authorization server. Assemble a set called **RequestedScopes** containing the scopes the client most recently requested at the token endpoint. The permission ticket that was presented by the client at the token endpoint represents some number of resources, each with some number of scopes; for each of those resources, assemble a set called **TicketScopes(resource)** containing the scopes associated with that resource.
2. For each resource in the permission ticket, determine a final set of requested scopes as follows: `RequestedScopes(resource)={TicketScopes(resource) ∪ {RegisteredScopes ∩ RequestedScopes}}`. Treat each scope in {RegisteredScopes ∩ RequestedScopes} as matching any available scope associated with a resource found in the permission ticket.
3. For each RequestedScopes(resource) set, determine all operative policy conditions, and claims and other relevant information serving as input to them, and evaluate its authorization status.
4. For each scope in RequestedScopes(resource) that passes the evaluation, add it to a set called **CandidateGrantedScopes(resource)**.

----

> Note: Claims and other information gathered during one authorization process may become out of date in terms of their relevance for future authorization processes. The authorization server is responsible for managing such relevance wherever information associated with a PCT, or other persistently stored information, is used as input to authorization, including policy conditions themselves.

> Note: Since the authorization server's policy expression and evaluation capabilities are outside the scope of this specification, any one implementation might take a simple or arbitrarily complex form, with varying abilities to combine or perform calculations over claims and their values. For example, logical operations such as accepting "either claim value A or claim value B" as correct are possible to implement.

In the authorization results phase, the authorization server examines each **CandidateGrantedScopes(resource)** set to determine whether to issue an RPT and what permissions should be associated with it. If all RequestedScopes(resource) sets can be granted (that is, `{∪ resource {RequestedScopes\CandidateGrantedScopes}={}`), then the authorization server subsequently responds with a success code and issues an RPT containing **CandidateGrantedScopes** for each resource.

Otherwise, the authorization server subsequently issues either an RPT containing **CandidateGrantedScopes** for each resource, or one of the error codes, as appropriate. The reason for the two options is that granting only partial scopes might not be useful for the client's and requesting party's purposes in seeking authorization for access. The choice of error depends on policy conditions and the authorization server's implementation choices. The conditions for the `need_info`, `request_denied`, and `request_submitted` error codes are dependent on authorization assessment and thus these codes might be more likely than the others to be issued subsequent to such a calculation.

----

The following example illustrates authorization assessment and partial results. 

- The resource server has three of the resource owner's resources of interest to the client and requesting party, photo1 and photo2 with scopes `view`, `resize`, `print`, and `download`, and album with scopes `view`, `edit`, and `download`. It considers photo1 and photo2 to be logically "inside" album.
- Though the exact contents of RPTs, permissions, and permission requests are opaque to the client, the resource server has documented its API, available scopes, and permission requesting practices. For example, if the client requests an album resource, it expects that the resource server will request a permission for the album with a scope that approximates the attempted client operation, but will also request permissions for all the photos "inside" the album, with view scope only.
- The client has a pre-registered scope of `download` with the authorization server. This enables the client later to request this scope dynamically on behalf of its requesting party from the token endpoint. The authorization server assembles the set **RegisteredScopes** with contents of scope download.
- The client requests the album resource in an attempt to edit it, so the resource server obtains a permission ticket with three permissions in it: for album with a scope of `edit`, and for photo1 and photo2, each with a scope of `view`. The authorization server assembles the following sets: **TicketScopes(album)** containing `edit`, **TicketScopes(photo1)** containing `view`, and **TicketScopes(photo2)** containing `view`.
- While asking for an RPT at the token endpoint, the client requests `download` scope on the requesting party's behalf. The authorization server determines the contents of the following sets: **RequestedScopes(album)** containing `edit` and `download`, **RequestedScopes(photo1)** containing `view` and `download`, and **RequestedScopes(photo2)** containing `view` and `download`.
- The resource owner has set policy conditions that allow access by this particular requesting party only to photo1 and only for `view` scope.
- Based on the authorization server's authorization assessment calculation, it determines the contents of the following sets: **CandidateGrantedScopes(album)** containing no scopes, **CandidateGrantedScopes(photo1)** containing `view`, and **CandidateGrantedScopes(photo2)** containing no scopes. This adds up to less than in the corresponding **RequestedScopes** sets. The authorization server therefore has a choice whether to issue an RPT (in this case, containing a permission for photo1 with view scope) or an error (say, request_denied, or request_submitted if has a way to notify the resource owner about the album editing resource request and seek an added policy covering it).

----

###Authorization Server Response to Client on Authorization Success

If the authorization server's assessment process results in issuance of permissions, *it issues the RPT with which it has associated the permissions by using the successful response form defined in Section 5.1 of [RFC6749]*.

The authorization server MAY return a refresh token. See Section 3.6 for more information about refreshing an RPT.

The authorization server MAY add the following parameters to its response:


1. pct

    OPTIONAL. A correlation handle representing claims and other information collected during this authorization process, which the client is able to present later in order to optimize future authorization processes on behalf of a requesting party. The PCT MUST be unguessable by an attacker. The PCT MUST NOT disclose claims from the requesting party directly to possessors of the PCT. Instead, such claims SHOULD be associated by reference to the PCT or expressed in an encrypted format that can be decrypted only by the authorization server that issued the PCT. See Section 3.3.2 for more information about the end-user requesting party interaction option. See Section 5.2 for additional PCT security considerations.
1. upgraded

    OPTIONAL. Boolean value. If the client submits an RPT in the request and the authorization server includes the permissions of the RPT from the request as part of the newly issued RPT, then it MUST set this value to true. If it sets the value to false or the value is absent, the client MUST act as if the newly issued RPT does not include the permissions associated with the RPT from the request. (See Section 3.3.5.1.)

----

##Client Request Resource and Provides an RPT

The client requests the resource, now *in possession of an RPT*. The client *uses [RFC6750] for a bearer token*, and any other suitable presentation mechanism for an RPT of another access token type.

Example of a client request for the resource carrying an RPT:

    GET /users/alice/album/photo.jpg HTTP/1.1
    Authorization: Bearer sbjsbhs(/SSJHBSUSSJHVhjsgvhsgvshgsv
    Host: photoz.example.com
    ...

----

##Resource Server Responds to Client's RPT-Accompanied Resource Request

The resource server responds to the client's RPT-accompanied resource request.

If the resource request fails, the resource server responds as if the request were unaccompanied by an access token, as defined in Section 3.2.

The resource server MUST NOT give access in the case of an invalid RPT or an RPT associated with insufficient authorization.

For an example of how the resource server can introspect the RPT and its permissions at the authorization server prior to responding to the client's request, see [UMAFedAuthz].

----

##Authorization Server Refreshes RPT

As noted in Section 3.3.5, when issuing an RPT, the authorization server MAY also issue a **refresh token**.

Having previously received a refresh token from the authorization server, the client MAY use the refresh token grant as defined in [RFC6749] to attempt to refresh an expired RPT. If the client includes the scope parameter in its request, the authorization server MAY limit the scopes in the permissions associated with any resulting refreshed RPT to the scopes requested by the client.

The authorization server MUST NOT perform an authorization assessment calculation on receiving the client's request to refresh an RPT.

----

##Client Requests Token Revocation

If the authorization server presents a token revocation endpoint as defined in [RFC7009], the client MAY use the endpoint to request revocation of an RPT (access token), refresh token, or PCT previously issued to it on behalf of a requesting party. This specification defines the following token type hint value:

- pct
  
    Helps the authorization server optimize lookup of a PCT for revocation.

****

#Profiles and Extensions

An UMA profile restricts UMA's available options. An UMA extension defines how to use UMA's extensibility points. The two can be combined. Some reasons for creating profiles and extensions include:

- A profile restricting options in order to tighten security
- A profile/extension restricting options and adding messaging parameters for use with a specific industry API
- A profile that documents a specific URI, format, and *interpretation for pushed claim tokens* (see Section 3.3.1)
- An extension that defines additional metadata for the authorization server discovery document to define machine-readable usage details

The following actions are RECOMMENDED regarding the creation and use of profiles and extensions:

- The creator of a profile or extension related to UMA SHOULD assign it a uniquely identifying URI.
- The authorization server supporting a profile or extension related to UMA with such a URI SHOULD supply the identifying URI in its uma_profiles_supported metadata (see Section 2).

----

#Security Considerations

This specification relies mainly on OAuth 2.0 security mechanisms as well as transport-level security. Thus, implementers are strongly advised to read [BCP195] and the security considerations in [RFC6749] (Section 10) and [RFC6750] (Section 5) along with the security considerations of any other OAuth token-defining specifications in use, along with the entire [RFC6819] specification, and apply the countermeasures described therein. As well, implementers should take into account the security considerations in all other normatively referenced specifications.

The following sections describe additional security considerations.

##Cross-Site Request Forgery

Redirection used for gathering claims interactively from an end-user requesting party (described in Section 3.3.2) creates the potential for cross-site request forgery (CSRF). This may be the result of an open redirect if the authorization server does not force the client to pre-register its claims redirection endpoint, and server-side artifact tampering if the client does not avail itself of the state parameter.

A CSRF attack against the authorization server's claims interaction endpoint can result in an attacker obtaining authorization for access through a malicious client without involving or alerting the end-user requesting party. The authorization server MUST implement CSRF protection for its claims interaction endpoint and ensure that a malicious client cannot obtain authorization without the awareness and involvement of the requesting party.

If the client uses the interactive claims gathering feature, it MUST implement CSRF protection for its claims redirection URI. It SHOULD use the `state` parameter when redirecting the requesting party to the claims interaction endpoint. The value of the `state` parameter MUST be unguessable by an attacker. Once the authorization server redirects the requesting party back, with the *required binding value* contained in the `state` parameter, the client MUST check that the value of the `state` parameter received is equal to the value sent in the initial redirection request. Depending on the type of application, a client has several methods for storing and later verifying the value of the `state` parameter in between the initial redirect and the eventual resulting request to the claims redirection URI, including storage in a server-side session-bound variable, cryptographic derivation from a browser cookie, or secure application-level storage. The client MUST treat requests containing an invalid or unknown state parameter value as an error.

The state parameter SHOULD NOT include sensitive client or requesting party information in plain text, as it is transmitted through third-party components (the requesting party's user agent) and could be stored insecurely.

----

##RPT and PCT Exposure

When a client redirects an end-user requesting party to the claims interaction endpoint, the client provides no a priori context to the authorization server about which user is appearing at the endpoint, *other than implicitly through the permission ticket*. Thus, a malicious client has the opportunity to switch end-users -- say, enabling malicious end-user Carlos to impersonate legitimate end-user Bob, who might be represented by a PCT already in that client's possession and might even have authorized the issuance of that PCT -- *after the redirect completes and before it returns to the token endpoint to seek permissions*.

To mitigate this threat, the authorization server, with the support of the resource owner, should consider the following strategies in combination.

- Require that the requesting party legitimately represent the wielder of the RPT on a legal or contractual level. This solution alone does not reduce the risk from a technical perspective.
- Gather claims interactively from an end-user requesting party that demonstrate that some sufficiently strong level of authentication was performed.
- Require claims to have a high degree of freshness in order for them to satify policy conditions.
- Tighten *time-to-live strategies* around RPTs and their associated permissions (see Section 6.1).

The client MUST only share the RPT (access token) with the resource server and authorization server, as explained in Section 10.3 of [RFC6749], and thus MUST keep it confidential from the requesting party. Because a malicious requesting party (the user of the client in the UMA grant) may have incentives to steal an RPT that the resource owner (the user of the client in other OAuth grants) does not, this security consideration takes on especial importance.

The PCT is similar to a refresh token in that *it allows non-interactive issuance of access tokens*. The authorization server and client MUST keep the PCT confidential in transit and storage, and MUST NOT share the PCT with any entity other than each other. The authorization server MUST maintain the binding between the PCT and the client to which it was issued.

Given that the PCT represents *a set of requesting party claims*, a client supplying a **PCT** in its **RPT** request MUST make a best effort to ensure that the requesting party using the client now is the same as the requesting party that was associated with the PCT when it was issued. Different clients will have different capabilities in this respect; for example, some applications are single-user and perform no local authentication, associating all PCTs with the "current user", while others might have more sophisticated authentication and user mapping capabilities.

If the authorization server has reason to believe that a PCT is compromised, for example, if the PCT has been supplied by a client that has "impossible geography" parameters, the authorization server should consider not using the claims based on that PCT in its authorization assessment.

----

##Strengthening RPT Protection Using Proof of Possession

After the client's resource request with an RPT, assuming the client sent an RPT of the bearer style such as defined in [RFC6750], the resource server will have received from the client *the entire secret portion of the token*. This specification assumes only bearer-type tokens because they are the only type standardized as of this specification's publication. However, to strengthen protection for RPTs using a *proof-of-possession approach*, the resource server could receive an RPT that consists of *only a cryptographically signed token identifier*, and then to validate the signature, it could, for example, submit the token identifier to the token introspection endpoint to obtain the necessary key information. The details of this usage are outside the scope of this specification.

----

##Credentials-Guessing

Permission tickets and PCTs are additional credentials that the authorization server MUST prevent attackers from guessing, as defined in Section 10.10 of [RFC6749].

----

##Permission Ticket Management

Within the constraints of making permission ticket values unguessable, the authorization server MAY format the permission ticket however it chooses, for example, either as a random string that references data held on the server or by including data within the ticket itself.

Permission tickets MUST be single-use. This prevents susceptibility to a session fixation attack.

1. The authorization server MUST invalidate a permission ticket when the client presents the permission ticket to either the token endpoint or the claims interaction endpoint, or when the permission ticket expires, whichever occurs first.
2. The client SHOULD check that the value of the ticket parameter it receives back from the authorization server in each response and each redirect of the requesting party back to it differs from the one it sent to the server in the initial request or redirect.

If the authorization server has reason to believe that a permission ticket is compromised, for example, because it has seen the permission ticket before and it believes the first appearance was from a legitimate client and the second appearance is from an attacker, it should consider invalidating any access tokens based on this evidence.

Given that scenarios involving the `request_submitted` error code are likely to involve polling intervals, the permission ticket needs to last long enough to give the client a chance to attempt a polling request, which then needs to figure into other permission ticket security considerations.

----

##Naive Implementations of Default-Deny Authorization

While a reasonable approach for most scenarios is to implement the classic stance of default-deny ("everything that is not expressly allowed is forbidden"), corner cases can inadvertently result in default-permit behavior. For example, it is insufficient to create default "empty" policy conditions stating "no claims are needed", and then accept an empty set of supplied claims as sufficient for access during authorization assessment.

----

##Requirements for Pre-Established Trust Regarding Claim Tokens

When a client makes an RPT request, it has the opportunity to push a claim token to attempt to satisfy policy conditions (see Section 3.3.1).

Claim tokens of any format typically contain *audience restrictions*, and an authorization server would not typically be in the primary audience for a claim token held or generated by a client. It is RECOMMENDED to document how the client, authorization server, and any additional ecosystem entities and parties will *establish a trust relationship* and communicate any required keying material in a **claim token profile**, as described in Section 4. Authorization servers are RECOMMENDED not to accept claim tokens pushed by untrusted clients and not to ignore audience restrictions found in claim tokens pushed by clients.

Some deployments could have exceptional circumstances allowing the authorization server to validate claim tokens. For example, if the authorization server itself is also the **identity provider** for the requesting party, then it would be able to validate any ID token that the client pushes as a claim token and also validate the client to which it was issued.

----

##Profiles and Trust Establishment

Parties that are operating and using UMA software entities may need to *establish agreements about the parties' rights and responsibilities* on a legal or contractual level, along with common interpretations of UMA constructs for consistent and expected software behavior. These agreements can be used to improve the parties' respective security postures. Written profiles are a key mechanism for conveying and enforcing these agreements. Section 4 discusses profiling. See [UMA-legal] to learn about frameworks and tools to assist in the legal and contractual elements of deploying UMA-enabled services.

****

#Privacy

##Policy Condition Setting, Time-to-live Management, and Removal of Authrization Grant

The setting of policy conditions, the resource owner-authorization server interface, and the resource owner-resource server interface are outside the scope of this specification. (For an example of how a secure and authorized resource owner context can be established between the resource server and authorization server, see [UMAFedAuthz].)

A variety of flows and user interfaces for policy condition setting involving user agents for both of these servers are possible, each with different privacy consequences for end-user resource owners. As well, various authorization, security, and time-to-live strategies could be applied on a per-resource owner basis or a per-authorization server basis, as the entities see fit. Validity periods of RPTs, refresh tokens, permissions, caching periods for responses, and even OAuth client credentials are all subject to management. Different time-to-live strategies might be suitable for different resources and scopes.

> 多种权限控制需求

In order to account for modifications of policy conditions that result in the withdrawal of authorization grants (for example, fewer scopes, fewer resources, or resources available for a shorter time) in as timely a fashion as possible, the authorization server should align its strategies for management of these factors with resource owner needs and actions rather than those of clients and requesting parties. For example, the authorization server may want to invalidate a client's RPT and refresh token as soon as a resource owner changes policy conditions in such a way as to deny the client and its requesting party future access to a full set of previously held permissions.

> 权限修改的同步

----

##Requesting Party Information at the Authorization Server

Claims are likely to contain personal, personally identifiable, and sensitive information, particularly in the case of requesting parties who are end-users.

If the authorization server supports persisting claims for any length of time (for example, to support issuance of PCTs), then it SHOULD provide a secure and privacy-protected means of storing claim data. It is also RECOMMENDED for the authorization server to use an interactive claims-gathering flow to *ask an end-user requesting party for authorization to persist their claims before issuing a PCT*. A requesting party who provides claims to an authorization server once having been redirected there is less susceptible to privacy-destroying behavior. Otherwise, certain flows such as claims pushing and interactive federated sign-in with automatic login will tend to be invisible to the user if they have not consciously authorized the possibility.

> requesting party to hold persisted claim 

----

##Resource Owner Information at the Resource Server

Since the client's initial request for a protected resource is made in an unauthorized and unauthenticated context, such requests are by definition open to all users. The response to that request includes the authorization server's location to enable the client to *request an access token and present claims*. If it is known out of band that authorization server is owned and controlled by a single user, or visiting the authorization server contains other identifying information, then an unauthenticated and unauthorized client would be able to tell which resource owner is associated with a given resource. Other information about the resource owner, such as organizational affiliation or group membership, may be gained from this transaction as well.

> Resource server上应该存放authorization server's location, gain organizational affiliation, group membership from transaction

----

##Profiles and Trust Establishment

Parties that are operating and using UMA software entities may need to establish agreements about mutual rights, responsibilities, and common interpretations of UMA constructs for consistent and expected software behavior. These agreements can be used to improve the parties' respective privacy postures. See Section 5.8 for more information. Additional considerations related to Privacy by Design concepts are discussed in [UMA-PbD].

****

#IANA Consideration

This document makes the following requests of IANA.

##Well-known URI Registration

This specification registers the well-known URI defined in Section 2, as required by Section 5.1 of [RFC5785].

----

###Registry Contents

- URI suffix: uma2-configuration
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 2 in this document

----

##OAuth 2.0 Authorization Server Metadata Registry

This specification registers OAuth 2.0 authorization server metadata defined in Section 2, as required by Section 7.1 of [OAuthMeta].

###Registry Contents

- Metadata name: claims_interaction_endpoint
- Metadata description: endpoint metadata
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 2 in this document

- Metadata name: claims_interaction_endpoint
- Metadata description: endpoint metadata
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 2 in this document

----

##OAuth 2.0 Dynamic Client Registration Metadata Registry

This specification registers the parameters defined in Section 3.3.1 (claim push), as required by Section 11.2 of [RFC6749].

###Registry Contents

- Parameter name: claim_token
- Parameter usage location: client request, token endpoint
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 3.3.1 in this document

- Parameter name: pct
- Parameter usage location: client request, token endpoint
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 3.3.1 in this document

- Parameter name: pct
- Parameter usage location: authorization server response, token endpoint
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 3.3.5 in this document

- Parameter name: rpt
- Parameter usage location: client request, token endpoint
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 3.3.1 in this document

- Parameter name: ticket
- Parameter usage location: client request, token endpoint
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 3.3.1 in this document

- Parameter name: upgraded
- Parameter usage location: authorization server response, token endpoint
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 3.3.5 in this document

----

##OAuth 2.0 Extensions Error Registration

This specification registers the errors defined in Section 3.3.6, as required by Section 11.4 of [RFC6749].

###Registry Contents

- Error name: need_info (and its subsidiary parameters)
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 3.3.6 in this document
- Error usage location: authorization server response, token endpoint

- Error name: request_denied
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 3.3.6 in this document
- Error usage location: authorization server response, token endpoint

- Error name: request_submitted (and its subsidiary parameters)
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 3.3.6 in this document
- Error usage location: authorization server response, token endpoint

----

##OAuth Token Type Hints Registration

This specification registers the errors defined in Section 3.7, as required by Section 4.1.2 of [RFC7009].

###Registry Contents

- Hint value: pct
- Change controller: Kantara Initiative User-Managed Access Work Group - staff@kantarainitiative.org
- Specification document: Section 3.7 in this document

****

#Federated Authorization for User-Managed Access (UMA) 2.0

#Introduction

This specification extends and complements [UMAGrant] to loosely couple, or federate, its authorization process. This enables *multiple resource servers operating in different domains to communicate with a single authorization server operating in yet another domain that acts on behalf of a resource owner*. A service ecosystem can thus automate resource protection, and the resource owner can monitor and control authorization grant rules through the authorization server over time. Further, authorization grants can increase and decrease at the level of individual resources and scopes.

Building on the example provided in the introduction in [UMAGrant], bank customer (resource owner) Alice has a bank account service (resource server), a cloud file system (different resource server hosted elsewhere), and a dedicated sharing management service (authorization server) hosted by the bank. She can manage access to her various protected resources by spouse Bob, accounting professional Charline, financial information aggregation company DecideAccount, and neighbor Erik (requesting parties), all using different client applications. Her bank accounts and her various files and folders are protected resources, and she can use the same sharing management service to monitor and control different scopes of access to them by these different parties, such as viewing, editing, or printing files and viewing account data or accessing payment functions.

This specification, together with [UMAGrant], constitutes UMA 2.0. This specification is OPTIONAL to use with the UMA grant.

> bank customer Alice           <>  bank account
> clould file system            <>  resource server
> dedicated sharing management  <>  authorization server
> Bob, Charline, Erik           <>  Requesting parties
> different client applications <>  client

##Abstract Flow

The UMA grant defined in [UMAGrant] enhances the abstract protocol flow of OAuth. This specification enhances the UMA grant by *defining formal communications between the UMA-enabled authorization server and resource server* as they act on behalf of the resource owner, responding to authorization and resource requests, respectively, by a client that is acting on behalf of a requesting party.

A summary of UMA 2.0 communications, combining the UMA grant with federated authorization, is shown in Figure 1.

                                                 +------------------+
                                                 |     resource     |
           +------------manage (out of scope)----|       owner      |
           |                                     +------------------+
           |                                               |
           |                protection                     |
           |                API access                  control
           |                token (PAT)              (out of scope)
           |                                               |
           v                                               v
    +------------+                    +----------+------------------+
    |            |                    |protection|                  |
    |  resource  |                    |   API    |   authorization  |
    |   server   |<-----protect-------| (needs   |      server      |
    |            |                    |   PAT)   |                  |
    +------------+                    +----------+------------------+
    | protected  |                               |        UMA       |
    | resource   |                               |       grant      |
    |(needs RPT) |          requesting           |  (PCT optional)  |
    +------------+          party token          +------------------+
           ^                  (RPT)               ^  persisted   ^
           |                                      |   claims     |
           |                                    push   token     |
           |                                   claim   (PCT)     |
           |                                   tokens         interact
           |                                      +--------+    for
           +------------access--------------------| client |   claims
                                                  +--------+  gathering
                                                    +---------------+
                                                    |  requesting   |
                                                    |     party     |
                                                    +---------------+

This specification uses all of the terms and concepts in [UMAGrant]. This figure introduces the following new concepts:

- protection API
  
    The API presented by the **authorization server** to the resource server, defined in this specification. This API is OAuth-protected.
    
- protection API access token (PAT)
  
    An [RFC6749] access token with the scope uma_protection, used by the resource server as a client of the authorization server's protection API. The resource owner involved in the UMA grant is the same entity taking on the role of the resource owner authorizing issuance of the PAT.
    
    > Resource owner issue PAT to resource server by which means? Next section has answered.

----

##HTTP Usage, API Security, and Identity Context

This specification is designed for use with HTTP [RFC2616], and for interoperability and security in the context of loosely coupled services and applications operated by independent parties in independent domains. The use of UMA over any protocol other than HTTP is undefined. In such circumstances, it is RECOMMENDED to define **profiles or extensions** to achieve interoperability among independent implementations (see Section 4 of [UMAGrant]).

The authorization server MUST use **TLS protection** over its protection API endpoints, as governed by [BCP195], which discusses deployment and adoption characteristics of different TLS versions.

The authorization server MUST use **OAuth** and require a valid **PAT** to secure its protection API endpoints. The authorization server and the resource server (as an OAuth client) MUST support **bearer usage of the PAT**, as defined in [RFC6750]. All examples in this specification show the use of bearer-style PATs in this format.

As defined in [UMAGrant], the resource owner -- the entity here authorizing PAT issuance -- MAY be an end-user (natural person) or a non-human entity treated as a person for limited legal purposes (legal person), such as a corporation. *A PAT is unique to a resource owner, resource server used for resource management, and authorization server used for protection of those resources*. *The issuance of the PAT represents the authorization of the resource owner for the resource server to use the authorization server for protecting those resources*.

Different grant types for PAT issuance might be appropriate for different types of resource owners; for example, the **client credentials grant** is useful in the case of an organization acting as a resource owner, whereas an **interactive grant** type is typically more appropriate for capturing the approval of an end-user resource owner. Where an identity token is desired in addition to an access token, it is RECOMMENDED to use [OIDCCore] in addition.

> Grant such as whether give delegation or not

----

##Separation of Responsibility and Authority

Federation of authorization for the UMA grant delivers a conceptual separation of responsibility and authority:

- The resource owner can *control access to resources residing at multiple resource servers from a single authorization server*, by virtue of authorizing PAT issuance for each resource server. Any one resource server MAY be operated by a party different from the one operating the authorization server.
- The resource server defines *the boundaries of resources and the scopes available to each resource, and interprets how clients' resource requests map to permission requests*, by virtue of being the publisher of the API being protected and using the protection API to communicate to the authorization server.
- *The resource owner works with the authorization server to configure policy conditions (authorization grant rules)*, which the authorization server executes in the process of issuing access tokens. The authorization process makes use of claims gathered from the requesting party and client in order to satisfy all operative operative policy conditions.

The separation of **authorization decision making** and **authorization enforcement** is similar to the architectural separation often used in enterprises between **policy decision points** and **policy enforcement points**. However, the resource server MAY apply additional authorization controls beyond those imposed by the authorization server. For example, even if an RPT provides sufficient permissions for a particular case, the resource server can choose to bar access based on its own criteria.

> authorization decision making     <>  authorization server <- requesting party
> authorzation enforcement          <>  authorization server -> resource server
> separation                        <>  authorization server n<-->n resource server

Practical control of access among loosely coupled parties typically requires more than just messaging protocols. It is outside the scope of this specification to define more than the technical contract between UMA-conforming entities. Laws may govern authorization-granting relationships. *It is RECOMMENDED for the resource owner, authorization server, and resource server to establish agreements about which parties are responsible for establishing and maintaining **authorization grant rules** and other authorization rules on a legal or contractual level*, and parties operating entities claiming to be UMA-conforming should provide documentation of rights and obligations between and among them. See Section 4 of [UMAGrant] for more information.

> storage of authorization grant rule 

Except for PAT issuance, the resource owner-resource server and resource owner-authorization server interfaces -- including the setting of policy conditions -- are outside the scope of this specification (see Section 8 and Section 6.1 of [UMAGrant] for privacy considerations). Some elements of the protection API enable the building of user interfaces for policy condition setting (for example, see Section 3.2, which can be used in concert with user interaction for resource protection and sharing and offers an end-user redirection mechanism for policy interactions).

Note: The resource server typically requires access to *at least the permission and token introspection endpoints* when an end-user resource owner is not available ("offline" access). Thus, the authorization server needes to manage the PAT in a way that ensures this outcome. [UMA-Impl] discusses ways the resource server can enhance its error handling when the PAT is invalid.

----

##Protection API Summary

The protection API defines the following endpoints:

- **Resource registration endpoint** as defined in Section 3. 

    The API available at this endpoint provides a means for the **resource server** to put resources under the protection of an authorization server on behalf of the resource owner and manage them over time.
    
- **Permission endpoint** as defined in Section 4.

    This endpoint provides a means for the **resource server** to request a set of one or more permissions on behalf of the client based on the client's resource request when that request is unaccompanied by an access token or is accompanied by an RPT that is insufficient for access to that resource.
    
- OPTIONAL token introspection endpoint as defined in [RFC7662] and as extended in Section 5. This endpoint provides *a means for the resource server to introspect the RPT*.

Use of these endpoints assumes that the resource server has acquired **OAuth client credentials** from the authorization server by static or dynamic means, and has a valid **PAT**. Note: Although the resource identifiers that appear in permission and token introspection request messages could sufficiently identify the resource owner, the PAT is still required because *it represents the resource owner's authorization to use the protection API*, as noted in Section 1.3.

> the **client credentials grant** is useful in the case of an organization acting as a resource owner
> How about the interactive grant?

The authorization server MUST declare its protection API endpoints in the discovery document (see Section 2).

----

###Permissions

*A permission is (requested or granted) authorized access to a particular resource with some number of scopes bound to that resource*. The concept of permissions is used in authorization assessment, results calculation, and RPT issuance in [UMAGrant]. This concept takes on greater significance in relation to the protection API.

The resource server's resource registration operations at the authorization server result in a set of **resource owner-specific resource identifiers**. When the client makes a resource request that is unaccompanied by an access token or its resource request fails, *the resource server is responsible for interpreting that request and mapping it to a choice of authorization server, resource owner, resource identifier(s), and set of scopes for each identifier*, in order to request one or more permissions -- resource identifiers and a set of scopes -- and obtain a permission ticket on the client's behalf. Finally, when the client has made a resource request accompanied by an RPT and token introspection is in use, the returned token introspection object reveals the structure of permissions, potentially including expiration of individual permissions.

****

#Authorization Server Metadata

This specification makes use of the authorization server discovery document structure and endpoint defined in [UMAGrant]. The resource server uses this discovery document to discover the endpoints it needs.

In addition to the metadata defined in that specification and [OAuthMeta], this specification defines the following metadata for inclusion in the discovery document:

- permission_endpoint

    REQUIRED. The endpoint URI at which the **resource server** requests permissions on the client's behalf.
    
- resource_registration_endpoint

    REQUIRED. The endpoint URI at which the **resource server** registers resources to put them under authorization manager protection.

Following are additional requirements related to metadata:

- introspection_endpoint

    If the **authorization server** supports token introspection as defined in this specification, it MUST supply this metadata value (defined in [OAuthMeta]).
    
The authorization server SHOULD document any profiled or extended features it supports explicitly, ideally by supplying the URI identifying each UMA profile and extension as an uma_profiles_supported metadata array value (defined in [UMAGrant]), and by using extension metadata to indicate specific usage details as necessary.

****

#Resource Registeration Endpoint

The API available at the resource registration endpoint *enables the resource server to put resources under the protection of an authorization server on behalf of the resource owner and manage them over time*. Protection of a resource at the authorization server begins on successful registration and ends on successful deregistration.

The resource server uses a RESTful API at the authorization server's resource registration endpoint to create, read, update, and delete **resource descriptions**, along with retrieving lists of such descriptions. The descriptions consist of JSON documents that are maintained as web resources at the authorization server. (Note carefully the similar but distinct senses in which the word "resource" is used in this section.)

    authorization              resource         resource
        server                  server           owner
          |                       |                |
          |*PROTECTION API:       |                |
          |*Resource registration |                |
          |endpoint/API           |                |
          |                       |                |
          |*Create resource (POST)|                |
          |<----------------------|                |
          |*201 Created with      |                |
          |resource ID            |                |
          |---------------------->|                |
          |                       |                |
          |Set policy conditions (anytime          |
          |before deletion/deregistration)         |
          |<- - - - - - - - - - - - - - - - - - - -|
          |                       |                |
          |*Read (GET) with       |                |
          |resource ID            |                |
          |<----------------------|                |
          |*200 OK with resource  |                |
          |representation         |                |
          |---------------------->|                |
          |*Update (PUT) with     |                |
          |resource ID            |                |
          |<----------------------|                |
          |*200 OK with resource  |                |
          |ID                     |                |
          |---------------------->|                |
          |*List (GET)            |                |
          |<----------------------|                |
          |*200 OK with list of   |                |
          |resource IDs           |                |
          |---------------------->|                |
          |*Delete (DELETE) with  |                |
          |resource ID            |                |
          |<----------------------|                |
          |*200 OK or 204 No      |                |
          |Content                |                |
          |---------------------->|                |

    Figure 2: Resource Registration Endpoint and API: Requests and Success Responses
    
The resource server MAY protect any subset of the resource owner's resources using differenet authorization servers or other means entirely, or to protect some resources and not others. Additionally, the choice of protection regimes MAY be made explicitly by the resource owner or implicitly by the resource server. Any such partitioning by the resource server or owner is outside the scope of this specification.

> selective protection and the registeration request could be sent from resource server implicitly.

The resource server MAY register a single resource for protection that, from its perspective, *has multiple parts, or has dynamic elements such as the capacity for querying or filtering, or otherwise has internal complexity*. The resource server alone is responsible for maintaining any required *mappings between internal representations and the resource identifiers and scopes known to the authorization server*. 

Note: *The resource server is responsible for managing the process and timing of registering resources*, maintaining the registration of resources, and deregistering resources at the authorization server. Motivations for updating a resource might include, for example, new scopes added to a new API version or resource owner actions at a resource server that result in new resource description text. See [UMA-Impl] for a discussion of initial resource registration timing options.

****

##Resource Description##

A resource description is a **JSON** document that describes the characteristics of a resource sufficiently for an authorization server to protect it. A resource description has the following parameters:

- resource_scopes
  
    REQUIRED. **An array of strings**, serving as scope identifiers, indicating the available scopes for this resource. Any of the strings MAY be either a plain string or a URI.
- description
  
    OPTIONAL. A human-readable string describing the resource at length. The authorization server MAY use this description in any user interface it presents to a resource owner, for example, for resource protection monitoring or policy setting. The value of this parameter MAY be internationalized, as described in Section 2.2 of [RFC7591].
- icon_uri
  
    OPTIONAL. A URI for a graphic icon representing the resource. The authorization server MAY use the referenced icon in any user interface it presents to a resource owner, for example, for resource protection monitoring or policy setting.
- name
  
    OPTIONAL. A human-readable string naming the resource. The authorization server MAY use this name in any user interface it presents to a resource owner, for example, for resource protection monitoring or policy setting. The value of this parameter MAY be internationalized, as described in Section 2.2 of [RFC7591].
- type
  
    OPTIONAL. A string identifying the semantics of the resource. For example, if the resource is an identity claim that leverages standardized claim semantics for "verified email address", the value of this parameter could be an identifying URI for this claim. The authorization server MAY *use this information in processing information about the resource or displaying information about it in any user interface it presents to a resource owner*.
    
    {  
       "resource_scopes":[  
          "view",
          "http://photoz.example.com/dev/scopes/print"
       ],
       "description":"Collection of digital photographs",
       "icon_uri":"http://www.example.com/icons/flower.png",
       "name":"Photo Album",
       "type":"http://www.example.com/rsrcs/photoalbum"
    }

----

###Scope Description###

A scope description is *a JSON document* that describes the characteristics of a scope sufficiently for an authorization server to protect the resource with this available scope.

While a scope URI appearing in a resource description (see Section 3.1) MAY resolve to a scope description document, and thus scope description documents are possible to standardize and reference publicly, *the authorization server is not expected to resolve scope description details at resource registration time or at any other run-time requirement*. The resource server and authorization server are presumed to have negotiated any required interpretation of scope handling out of band.

> How could resource owner set policy if authorization server cannot resolve scope description.

A scope description has the following parameters:

- description
  
    OPTIONAL. A human-readable string describing the resource at length. The authorization server MAY use this description in any user interface it presents to a resource owner, for example, for resource protection monitoring or policy setting. The value of this parameter MAY be internationalized, as described in Section 2.2 of [RFC7591].
- icon_uri
  
    OPTIONAL. A URI for a graphic icon representing the scope. The authorization server MAY use the referenced icon in any user interface it presents to a resource owner, for example, for resource protection monitoring or policy setting.
    > Why is the scope description need a graphic icon?
- name
  
    OPTIONAL. A human-readable string naming the scope. *The authorization server MAY use this name in any user interface it presents to a resource owner*, for example, for resource protection monitoring or policy setting. The value of this parameter MAY be internationalized, as described in Section 2.2 of [RFC7591].
    
----

##Resource Registeration API##

The authoirzation server MUST support the following five registration options and MUST require a valid PAT for access for access to them; any other operations are undefined by this specification. Here `rreguri` stands for the resource registration endpoint and `_id` stands for the **authorization server-assigned identifier** for the web resource corresponding to the resource at the time it was created, *included within the URL returned in the Location header*. Each operation is defined in its own section below;

- Create resource description: POST rreguri/
- Read resource description: GET rreguri/_id
- Update resource description: PUT rreguri/_id
- Delete resource description: DELETE rreguri/_id
- List resource descriptions: GET rreguri/

Within the JSON body of a successful response, the authorization server includes common parameters, possibly in addition to method-specific parameters, as follows:

- `_id`

    REQUIRED (except for the Delete and List methods). A string value repeating the authorization server-defined identifier for the web resource corresponding to the resource. Its appearance in the body makes it readily available as an identifier for various protected resource management tasks.
    
- user_access_policy_uri

    OPTIONAL. A URI that allows the resource server to redirect an end-user resource owner to a specific user interface within the authorization server where the resource owner can immediately set or modify access policies subsequent to the resource registration action just completed. The authorization server is free to choose the targeted user interface, for example, in the case of a deletion action, enabling the resource server to direct the end-user to a policy-setting interface for an overall "folder" resource formerly "containing" the deleted resource (a relationship the authorization server is not aware of), to enable adjustment of related policies.

If the request to the resource registration endpoint is incorrect, then the authorization server instead responds as follows (see Section 6 for information about error messages):

- If the referenced resource cannot be found, the authorization server MUST respond with an **HTTP 404** (Not Found) status code and MAY respond with a not_found error code.
- If the resource server request used an unsupported HTTP method, the authorization server MUST respond with the **HTTP 405** (Method Not Allowed) status code and MAY respond with an unsupported_method_type error code.
- If the request is missing a required parameter, includes an invalid parameter value, includes a parameter more than once, or is otherwise malformed, the authorization server MUST respond with the **HTTP 400** (Bad Request) status code and MAY respond with an invalid_request error code.

----

###Create Resource Description###

****

#Permission Endpoint

The permission endpoint defines a means for the resource server to request one or more permissions (resource identifiers and corresponding scopes) with the authorization server on the client's behalf, and to receive a permission ticket in return, in order to respond as indicated in Section 3.2 of [UMAGrant]. The resource server uses this endpoint on the following occasions:

- After the client's initial resource request without an access token
- After the client's resource request that was accompanied by an invalid RPT or a valid RPT that had insufficient permissions associated with it


























****

#Case Study: Access Management 2.0 for the Enterprise

#Introduction

Although UMA's primary use cases have centered on individual people (that is, the "users" who manage access to their own online resources), the UMA notion of authorization as a service also has relevance to modern enterprises that *must secure APIs and other web resources in a developer-friendly way*.

#Problem Scenario

Where once web access management (WAM) and single sign-on (SSO) were sufficient for many purposes in the enterprise context, a new requirement has surfaced: managing access to an enterprise's web APIs, not just web apps. Today's systems for managing this type of access have a number of challenges.

Using current WAM solutions to provide API security can be unfriendly to developers, complex, expensive, and likely proprietary. Mobile clients struggle to deal with XML-based and SOAP-based security mechanisms. Enterprise IT struggles to deploy agents or proxies.

Since it's currently overly complex to centralize access authorization, we find too much authorization code in applications, which slows service delivery by forcing developers to redevelop authorization logic, as well as hindering effective auditing and policy administration.

WAM solutions are *not fully agnostic as to authentication method*. WAM solutions previously could make simplifying assumptions about how users authenticate (typically username and password into a web app). With mobile applications, game consoles, and other device types, and with strong authentication needs increasing, old assumptions are no longer viable.

APIs by their nature are subdivisions of functionality exposed at a single domain, and would map well to arbitrarily fine-grained policy, for example, at the method or even parameter level. However, outside the use of XACML, authorization policy granularity is coarse in traditional solutions: group filtering or URL regular expression matching at most. Further, it is often impractical to act according to policies from multiple authoritative sources.

----

#Proposed Improvement

UMA makes the following solutions possible.

As a profile of OAuth 2.0 (IETF RFCs 6749 and 6750) that is complementary to OpenID Connect, UMA defines *RESTful, JSON-based, standardized flows* and constructs for coordinating the protection of any API or web resource in a way that will be familiar to any developer already acquainted with OAuth. Mobile developers accept technologies that use HTTP and JSON at their core.

UMA's notion of **machine-readable resource set** and **scope descriptions** creates an access control mechanism that enables control over specific API scopes (customizable buckets of API functionality), not just domains. With UMA, client app developers can handle authorization tasks by calling simple REST/JSON endpoints; administrators don't have to deploy a web server agent or reverse proxy to enable centralization.

UMA defines interfaces between authorization servers and resource servers that, by default, *enable centralized policy decision-making* for improved service delivery, auditing, policy administration, and accountability, even in a very loosely coupled "public API" environment. Custom profiles enable flexibility to move the decision-making line outward to distributed applications, to account for local preferences in API ecosystems. UMA does not standardize a policy expression language, enabling flexibility in policy expression and evaluation through XACML, other declarative policy languages, or procedural code as warranted by conditions. It also has a fluid way to handle federated authorization policy.

> How CUSTOM PROFILE enable flexibility to move the decision-making line outward to distributed applications? Does this means that decision-making line is at authorization server part?

UMA inherits authentication agnosticism from OAuth. It concentrates on authorization, not on authentication. It has been profiled to work with OpenID Connect to gather identity claims from whoever is attempting access, and enables true claims-based authorization (with simple group- or role-based policies a natural subset).

----

#Solution Scenario

An organization – say, BusinessCo -- publishes numerous APIs. BusinessCo authorizes which people, clients, and networks can access a subset of the APIs. BusinessCo, as a subsidiary of ParentCo, relies on ParentCo to provide some of the required authorization policies.

When BusinessCo publishes and UMA-protects an API, its resource server acts as a policy enforcement point (PEP). The RS relies on an UMA authorization server to as a policy decision point (PDP) for it. The PEP can query multiple authorization servers to ensure that all required authorizations have been granted, for example the policies of both BusinessCo and ParentCo. In UMA trust model terminology, this scenario is in the category **non-person entity (NPE) sharing** because *the resource owner is a corporate entity that also operates its own authorization server*.

Enterprise resource users such as employees and partners operate client applications, such as web and mobile apps, in order to request access. How the respective PDPs make authorization decisions about these users and clients is up to the implementation. Each authorization server may itself be a policy information point (PIP) at which policies reside, or it may be a client of one or more PIP services. To understand the nature of the requesting party, a PDP might be sent **SAML- or OpenID Connect-based tokens** by the requesting party's client, or may itself need to call out to an identity provider.

The PDP service would expose policy administration point (PAP) functions to IT administrators in some fashion. BusinessCo would need the capability to express their access policies; for example, BusinessCo or ParentCo might interface a standard enterprise entitlements management system that expresses polices in XACML or some other standard language.

> users                 <->     requesting party
> client                <->     web and mobile apps
> resource server       <->     PEP
> authorization server  <->     PDP&PIP
> PAP                   <->     PAT

----

#Solution Flow

This scenario uses ordinary UMA flows, noting that it is a human "Authorizing Party Agent", not BusinessCo, that sets policy and possibly performs any policy-dictated manual intervention to enable access requests to go through. The company Gluu has produced a swimlane diagram to illustrate.

> 



****

#Case Study: IoT - Intelligent Refrigerated Shipping Containers

#Introduction

This use case is adapted from studies here and here. It involves **a ship hauling intelligent “reefers”** (refrigerated containers) and **tracking environmental factors** (e.g., temperature, humidity) to ensure that the contents arrive in good conditions to their destination.

The containers are equipped with an array of sensors (e.g., temperature, humidity, location, shock) connected to an embedded microprocessor with some compute power for basic calculations. The containers expose RESTful APIs with information about sensors and status. They also communicate with **a cloud service** for analytics and reporting purposes. They are also equipped with a wide variety of network antennas, which might include cellular, Wi-Fi, and satellite (this varies widely depending on the type and cost of the container)

The ship needs access to the sensors on the containers, so that the crew can easily monitor cargo status and track dynamic distribution policies such as First Expire First Out (FEFO). We assume that there is a standard set of APIs for the different sensors and high-level functionality available for the vessel to communicate with the reefers.

----

#Problem Scenario

hile the ship is docked at the port, it maintains constant network connectivity with different cloud services (same is true for reefers). As reefers are loaded, the ship communicates with the sensors and establishes a trust relationship. The ship will need to access the information on the sensors en route, even in locations were connectivity is not available.

The ship will get initial readings from the relevant sensors in every reefer while docked, plot its course and then start navigation. Once en route, the ship will continue updating the readings for every sensor. While sensors might be able to connect to the cloud in order to validate trust information from the ship, *this might not always be possible: The reefers need to be able to cache trust validation info for making offline decisions*.

Based on the retrieved information and in case where the cargo may be at risk, the ship may alter delivery plans or attempt communication with cloud services for further instructions.

----

#Proposed Improvements

UMA makes this scenario possible, where the reefers (and their individual sensors and high level APIs) are the Resource Servers, and the ship acts as the Client. The ship operator is the Requesting Party (although in this scenario the Client is heavily automated, possibly by having an embedded credential) and the reefer operator is the Resource Owner (also, possibly automated in the reefer itself or with a pre-defined policy). The Authorization Server is managed by a neutral party, such as a logistics company.

> reefers           <>  resource server
> ship              <>  client
> ship operator     <>  requesting party
> reefer operator   <>  Resource owner
> neutral party     <>  authorization server

The reefers are provisioned at loading time, that is, each of the Resources exposed by the reefer are registered with the authorization server on behalf of the reefer operator (with a proper PAT), and a policy is pre-established that will allow the ship operator to access the APIs exposed by the reefer. If for any reason this policy is not properly provisioned, access to the reefer’s APIs would require the reefer operator to grant access (not desirable in most situations)

> reefer operator grant reefer to register on authorization server
> policy allows ship operator to access API

When the reefers are loaded into the ship, the ship will “discover” them (e.g., RFID tags or similar) and will start querying their APIs. A standard UMA flow is expected at this point, where the ship software is required to get an **RPT** (based on an **AAT** that is obtained with the ship operator’s credentials). Since the ship is docked and connectivity is available, the reefers will be able to interact with the **AS** in order to validate the access request.

At this point, the reefers are expected to validate an RPT even with no network connectivity. There are a couple of alternatives here: we can either establish a long enough expiration time for the RPT, so that the response from the AS can be cached for at least that period of time. This expiration time should be long enough for most trips, plus an added margin, so that the reefers can provide service even when connectivity is not available during the entire trip. A second alternative would be considering **self-contained RPTs** that can be validated by the reefer without need to contact the AS. Another alternative might be for the reefers to perform a more lax trust decision, e.g., by overriding expiration times if connectivity is not detected for a given period of time. These are all aspects to be weighed in at RS design time, since the goal of preserving the cargo is paramount.

The ship can hen continue to access the sensor information for the reefers with the original RPT, and it might decide to **refresh** them when connectivity is available.

If reefers are changed from ship to ship while visiting an intermediate port, the target ship will perform the same operation as described above, obtaining its own RPT for accessing the reefers. If for any reason a policy has not been defined at the AS for a particular ship (Client), operator (Requesting Party) and reefer (Resource Server) combination, communication with the reefer operator (Resource Owner) may be required for access request. While unlikely, we would expect a complete solution to include this flow for completeness.

> 




























